{
 "api": [
  {
   "body": "return self()\r\n",
   "kind": "func",
   "name": "ref",
   "path": "ISAACPlayer24H.ref"
  },
  {
   "body": "if(self.helper ~= nil) then\r\n\tself.uninit()\r\n\tUtils.Timer.sleep(1000)\r\nend\r\n\r\n\r\nself.UI.ModuleName(self()..\"\",true)\r\nself.codeToString = function (code)\r\n\tlocal res = \"( Code: \"..math.tointeger(code);\r\n\tif code < 1 then\r\n\t\tres = res..\", not reachable\"\r\n\tend\r\n\treturn res..\")\"\r\nend\r\nself.forceStop = false\r\nself.Helper.registerLog()\r\n\r\nself.parseTimestring = function(str)\r\n    if(type(str) == \"number\") then \r\n        return str\r\n    end\r\n\tif(str == nil or str == \"\") then \r\n\t\treturn nil\r\n\tend\r\n\tlocal n, base = string.match(str, \"(%d+)(%a+)\")\r\n\tif(base == nil )then\r\n\t\t n = string.match(str, \"%d+\")\r\n\tend\r\n\tif n == nil then \r\n\t\treturn nil \r\n\tend\r\n\tn = tonumber(n)\r\n\tif(base == nil) then\r\n\t\treturn n\r\n\telse\r\n\t\tif base == \"s\" then\r\n\t\t\treturn n\r\n\t\tend\r\n\t\tif base == \"m\" then\r\n\t\t\treturn n*60\r\n\t\tend\r\n\t\tif base == \"h\" then\r\n\t\t\treturn n*60*60\r\n\t\tend\r\n\tend\r\n\treturn n\r\nend\r\n\r\nfunction get_timezone_diff_seconds()\r\n  local now = os.time()\r\n  local off = os.difftime(now, os.time(os.date(\"!*t\", now)))\r\n  if os.date(\"*t\", now).isdst then\r\n\treturn off +3600\r\n\tend\r\n  return off\r\nend\r\n\r\nself.tzOffset = get_timezone_diff_seconds()\r\n\r\nself.log(1,\"TimezoneOffset [h]:\",self.tzOffset/3600)\r\n--pixc.log(\"log\",self.log)\r\n--logNever = 0,\r\n--logFatal,\r\n--logError,\r\n--logWarning,\r\n--logInfo,\r\n--logDebug\r\nrequire \"pixcHelper\"\r\nrequire \"pixcProtocolHttp\"\r\nrequire \"pixcNetwork\"\r\nmath.randomseed(os.time())\r\nself.stop = false\r\nif self.pixcHelper ~= nil then\r\n\treturn \r\nend\r\nif self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\n\r\n\r\n\r\n\r\nself.network = createPixcNetwork()\r\nself.helper = createPixcHelper(pixc,self())\r\nself.Player.registerPlayerFunctions()\r\nself.Helper.registerHelperFunctions()\r\nself.maxWebLogLength = tonumber(self.helper:getProperty(\"Max Log Length (Web)\",\"100\",\"Expert\"))\r\nself.instantPlayFadeTimeS = tonumber(self.helper:getProperty(\"Instant Play Fadetime (ms)\",\"2000\",\"Timeline\"));\r\nself.instantPlayFadeTimeS = self.instantPlayFadeTimeS/1000;\r\nif(self.instantPlayFadeTimeS < 0) then\r\n\tself.instantPlayFadeTimeS = 0;\r\nend\r\n\r\nself.removeMinDurationAfterEnd = tonumber(self.helper:getProperty(\"Keep Clips For Minutes After Ending\",\"60\",\"Timeline\"));\r\nif(self.removeMinDurationAfterEnd < 0) then\r\n\tself.removeMinDurationAfterEnd = 0;\r\nend\r\nself.instantPlayFadeTimeS = self.instantPlayFadeTimeS/1000;\r\nif(self.instantPlayFadeTimeS < 0) then\r\n\tself.instantPlayFadeTimeS = 0;\r\nend\r\nself.UI.started(true,true)\r\nself.Errorhelper.clearErrors()\r\nself.Errorhelper.addError(\"Initializing\",\"info\")\r\nself.logLevel = 5;\r\nself.heartbeatErrorCount = nil;\r\nself.scheduleUpdateCounter = 0;\r\nself.scheduleUpdateDone = false;\r\nself.scheduleUpdateActive = false\r\n\r\nself.helper.arrayRemove = function (t, fnKeep,extInfo,optPreRm)\r\n    local j, n = 1, #t;\r\n\r\n    for i=1,n do\r\n        if (fnKeep(t, i, j,extInfo)) then\r\n            -- Move i's kept value to j's position, if it's not already there.\r\n            if (i ~= j) then\r\n                t[j] = t[i];\r\n                t[i] = nil;\r\n            end\r\n            j = j + 1; -- Increment position of where we'll place the next kept value.\r\n        else\r\n\t\t\tif(optPreRm ~= nil) then\r\n\t\t\t\toptPreRm(t[i])\r\n            \tt[i] = nil;\r\n\t\t\telse\r\n\t\t\t\tt[i] = nil;\r\n\t\t\tend\r\n        end\r\n    end\r\n\r\n    return t;\r\nend\r\n\r\nself.helper.toBool = function (str, default)\r\n    if type(str) == 'boolean' then \r\n        return str \r\n    end\r\n    if( str == \"true\") then\r\n        return true\r\n    end\r\n    if( str == \"false\") then\r\n        return false\r\n    end\r\n    return default\r\nend\r\nif self.helper.dedupArray == nil then\r\n\tself.helper.dedupArray = function (data)\r\n\t\tif data == nil or type(data) ~= \"table\" then return data end;\r\n\t\t\r\n\t\tlocal hash = {}\r\n\t\tfor _,v in ipairs(data) do\r\n\t\t\thash[v] = true\r\n\t\tend\r\n\t\tlocal res = {}\r\n\t\tfor k,_ in pairs(hash) do\r\n\t\t\tres[#res+1] = k\r\n\t\tend\r\n\t\treturn res;\r\n\tend\r\nend\r\nif self.helper.framesToHms == nil then\r\n\tself.helper.framesToHms = function (frames,fps)\r\n\t\tlocal hour = string.format(\"%02d\",math.floor(frames / (fps * 60 * 60)))\r\n\t\tlocal minute = string.format(\"%02d\",math.floor(frames / (fps * 60) - (hour * 60)))\r\n\t\tlocal second = string.format(\"%02d\",math.floor(frames / (fps) - (minute * 60 + hour * 3600)))\r\n\t\treturn hour .. ':' .. minute .. ':' .. second\r\n\tend\r\nend\r\nself.version = self.helper:getProperty(\"Version\",\"\")\r\nself.log(1,\"Module Version: \"..self.version)\r\n--self.useNasSmb = self.helper:getProperty(\"Use Nas SMB Server\",\"false\")\r\n--self.useNasSmb = self.helper.toBool(self.useNasSmb,false)\r\n--self.smbPath = self.helper:getProperty(\"SMB Server Path\",\"\\\\SERVER\\\\DIR\")\r\n--if (self.smbPath == nil or type(self.smbPath) ~='string') then\r\n--    self.useNasSmb = false\r\n--end\r\nself.smbPath = \"\\\\\\\\IP\\\\SMBTest\"\r\n--self.useNasSmb = true\r\n\r\nself.protocol = createPixcProtocolHttp()\r\nself.avCall = require(\"pixcCall\")\r\nself.protocol:setStatusCallbacks(\r\n\tfunction (...) self.log(1,...) end)\r\n\r\nlocal getTimeLineHandle = function(name)\r\n\tif(name == \"\") then \r\n\t\treturn nil\r\n\tend\r\n\t\r\n\tlocal pixeraRef = self.Pixera()\r\n\tif(pixeraRef == nil) then\r\n\t\tself.log(1,\"Pixera not referenced\")\r\n\t\treturn\r\n\tend\r\n\tlocal arr = pixeraRef.Timelines.getTimelines()\r\n\r\n\tif(arr == nil) then\r\n\t\tself.log(1,\"getTimelines returned nil\")\r\n\t\treturn\r\n\tend\r\n\tfor _,t in ipairs(arr) do\r\n\t\t\r\n\t\tif t.getName()  == name then\r\n\t\t\treturn t;\r\n\t\tend\r\n\tend\r\n\tself.log(1,\"Timeline with name \"..name..\" not found\")\r\nend\r\n\r\nself.url = self.helper:getProperty(\"ISAAC URL\",\"\",\"Startup\")\r\nself.timelineMainName = self.helper:getProperty(\"Timeline Main Name\",\"\",\"Startup\")\r\nself.timelineInstantName = self.helper:getProperty(\"Timeline Instant Name\",\"\",\"Timeline\")\r\nself.timelineMainHandle = getTimeLineHandle(self.timelineMainName)\r\n--pixc.log(self.timelineMainName,self.timelineMainHandle,self.TimelineMain())\r\nself.instantPlayMode = self.helper:getProperty(\"Instant Play Mode\", \"Disabled\",\"Timeline\")\r\nif self.instantPlayMode == \"Disabled\" then\r\n\tself.stopTlInstantPlay = false\r\n\tself.enableInstantPlay = false\r\nelse \r\n\tif self.instantPlayMode == \"Enabled\" then\r\n\t\tself.stopTlInstantPlay = false\r\n\t\tself.enableInstantPlay = true\r\n\telse\r\n\t\tself.stopTlInstantPlay = true\r\n\t\tself.enableInstantPlay = true\r\n\tend\r\nend\r\nif(self.enableInstantPlay == true) then\r\n\tself.timelineInstantHandle = getTimeLineHandle(self.timelineInstantName)\r\n\tself.instantPlayWaitForMedia = self.helper:getProperty(\"Wait For Instant Media\",\"true\",\"Timeline\")\r\n\tself.instantPlayWaitForMedia = self.helper.toBool(self.instantPlayWaitForMedia,true)\r\nend\r\nself.Player.cleanTimeline(self.timelineInstantHandle)\r\nif(self.TimelineMain() == nil) then\r\n\tself.Errorhelper.addError(\"Missing Timeline Main\",\"error\")\r\n\tself.uninit()\r\n\treturn\r\nend\r\nif(self.enableInstantPlay == true and self.TimelineInstant() == nil) then\r\n\tself.Errorhelper.addError(\"Missing Timeline Instant\",\"error\")\r\n\tself.uninit()\r\n\treturn\r\nend\r\nself.TimelineMain().setOpacity(1)\r\nself.tlFps = self.TimelineMain().getFps()\r\nself.loopCue24Pos =24*60*60*self.tlFps\r\nself.InstantPlayPos = self.loopCue24Pos + 60*self.tlFps\r\nself.externalId = self.helper:getProperty(\"ISAAC Module ID \",\"pixeraMedia-\",\"Startup\")\r\nself.externalIdSchedule = self.helper:getProperty(\"Schedule ID For Schedule (If Different)\",\"\",\"Expert\")\r\nif(self.externalIdSchedule == nil or self.externalIdSchedule == \"\") then\r\n\tself.externalIdSchedule = self.externalId;\r\nend\r\nself.mappedContentFolder = self.helper:getProperty(\"Pixera Media Resource Folder\",\"My Media\",\"Content\")\r\nself.mediaOverlayContentFolder = self.helper:getProperty(\"Transition Resource Folder\",\"My Transition\",\"Transition\")\r\nself.mediaOverlayContentFolderHandle = pixc.getRoot().Pixera.Resources.getResourceFolderWithNamePath(\"Media/\"..self.mediaOverlayContentFolder)\r\nif(self.mediaOverlayContentFolderHandle == nil or self.mediaOverlayContentFolderHandle.getHandleInt() == 0) then\r\n\tself.mediaOverlayContentFolderHandle = nil\r\nend\r\nself.ContentHandling.addResourceFolderIfMissing(\"Media\",self.mappedContentFolder..\"/image\")\r\nself.ContentHandling.addResourceFolderIfMissing(\"Media\",self.mappedContentFolder..\"/video\")\r\nself.ContentHandling.addResourceFolderIfMissing(\"Media\",self.mappedContentFolder..\"/audio\")\r\nself.ContentHandling.addResourceFolderIfMissing(\"Media\",self.mappedContentFolder..\"/other\")\r\nself.ContentHandling.addResourceFolderIfMissing(\"Media\",self.mediaOverlayContentFolder)\r\nself.contentDirectory = self.helper:getProperty(\"ISAAC Downloaded Media Directory\",\"D:/MyMedia/\",\"Startup\")\r\n\r\n--self.consoleLogFile = self.helper:getProperty(\"Downloader ConsoleLogFile\",\"d:/Log.log\")\r\n--self.consolLogFileEnable = self.helper:getProperty(\"Downloader ConsoleLog Enable\",\"true\")\r\n--if(self.consolLogFileEnable == false or self.consolLogFileEnable == \"false\") then\r\n--\tself.consoleLogFile = nil\r\n--end\r\nself.dissolveDuration = tonumber(self.helper:getProperty(\"Transition Duration (ms)\",\"5000\",\"Transition\"))\r\nself.dissolveInMs = tonumber(self.helper:getProperty(\"Transition Dissolve In (ms)\",\"1000\",\"Transition\"))\r\nself.dissolveOutMs = tonumber(self.helper:getProperty(\"Transition Dissolve Out (ms)\",\"2000\",\"Transition\"))\r\nself.dissolveHighOffsetMs = tonumber(self.helper:getProperty(\"Transition Offset (ms)\",\"0\",\"Transition\"))\r\n\r\nself.dissolveHighMs = self.dissolveDuration - (self.dissolveInMs + self.dissolveOutMs )\r\nif(self.dissolveHighMs < 0) then\r\n\tself.dissolveHighMs = 0\r\nend\r\nself.maximumBridgeGapS = tonumber(self.helper:getProperty(\"Max Transtition Length (s)\",\"10\",\"Transition\"))\r\nif self.dissolveInMs < 0 then self.dissolveInMs = 0 end\r\nif self.dissolveHighMs < 0 then self.dissolveHighMs = 0 end\r\nif self.dissolveOutMs < 0 then self.dissolveOutMs = 0 end\r\nlocal dur = self.dissolveInMs + self.dissolveHighMs/2 -18;\r\nlocal dur2 = self.dissolveOutMs + self.dissolveHighMs/2 -18;\r\nif(self.dissolveHighOffsetMs ~= 0) then\r\n\r\n\tif (self.dissolveHighOffsetMs < 0 and self.dissolveHighOffsetMs < dur2*-1) then\r\n\t\tself.dissolveHighOffsetMs = dur2*-1\r\n\tend\r\n\tif self.dissolveHighOffsetMs >0 and self.dissolveHighOffsetMs > dur then\r\n\t\tself.dissolveHighOffsetMs = dur\r\n\tend\r\nend\r\n\r\nself.elementsToPull = self.helper:getProperty(\"Max Playables To Build On Timeline\",\"25\",\"Timeline\")\r\n\r\n\r\nself.timoutResetMin = self.helper:getProperty(\"Timer Reset (Min)\",\"15\",\"Expert\")\r\nself.timoutResetMin = tonumber(self.timoutResetMin)\r\nif self.timoutResetMin ~= nil and self.timoutResetMin < 0.6 then\r\n\tself.timoutResetMin = nil\r\nend\r\n\r\n\r\nself.LiveSystemToMonitor = self.helper:getProperty(\"LiveSystemToMonitor\",\"Local\",\"Expert\")\r\nself.transitionMode = self.helper:getProperty(\"Transition Mode\",\"Cut\",\"Transition\")\r\nif self.transitionMode == \"Cut\" then\r\n\tself.dissolveInMs = 0\r\n\tself.dissolveOutMs  = 0\r\nend\r\nlocal applyDur = self.helper:getProperty(\"Apply Transition Dissolve To\",\"Stills\",\"Transition\")\r\nif applyDur == \"Stills\" then\r\n\tself.applyDisolveOnVideo = false\r\nelse\r\n\tself.applyDisolveOnVideo = true\r\nend\r\n\r\n\r\nlocal m = self.helper:getProperty(\"Transition Duration Of Video\",\"Transition Duration\",\"Transition\")\r\nif(m == \"Transition Duration\") then\r\n\tself.limitVideoBlendDuration = true\r\nelse\r\n\tself.limitVideoBlendDuration = false\r\nend\r\nself.reinitOnSystemTimeChange = self.helper:getProperty(\"Reinit On SystemTimeChange\",\"true\",\"Expert\")\r\nself.reinitOnSystemTimeChange = self.helper.toBool(self.reinitOnSystemTimeChange,false)\r\nself.checkPendingTransfers = self.helper:getProperty(\"Wait For SMB Transfers\",\"false\",\"Expert\")\r\nself.checkPendingTransfers = self.helper.toBool(self.checkPendingTransfers,false)\r\nself.fadeMediaIfOverlapping = self.helper:getProperty(\"Fade If Overlapping\",\"false\",\"Timeline\")\r\nself.fadeMediaIfOverlapping = self.helper.toBool(self.fadeMediaIfOverlapping,false)\r\nself.timelineUpdatePauseSupported = self.helper:getProperty(\"Pause Timeline UI Update\",\"false\",\"Expert\")\r\nself.timelineUpdatePauseSupported = self.helper.toBool(self.timelineUpdatePauseSupported,false)\r\nif timelineUpdatePauseSupported == true then\r\n\tself.timelineUpdatePauseSupported = nil\r\nend\r\n--if (self.dissolveInMs > 0.1) or (self.dissolveOutMs > 0.1) then self.centerMediaOverlay = false end\r\nself.mediaOverlayFixedResourceName = self.helper:getProperty(\"Transition Media Overlay Fixed Resource\",\"waterfall1.mp4\",\"Transition\")\r\nself.useTimecode = self.helper:getProperty(\"Use Timecode\",\"false\")\r\nself.useTimecode = self.helper.toBool(self.useTimecode,false)\r\nif self.useTimecode == true then\r\n\tPixera.Compound.setPauseSmpteInput(false)\r\nend\r\n\r\nself.compositionsEnabled = self.helper.toBool(self.helper:getProperty(\"Enable Compositions\",\"false\",\"Composition\"),false)\r\n\r\nself.compositionsGroupes = self.helper:getProperty(\"Composition Groups\",\"\",\"Composition\")\r\nself.compositionsGroupes = self.helper.stringSplit(self.compositionsGroupes,\";\")\r\nself.mergeTransitionToLayer = self.helper.toBool(self.helper:getProperty(\"Merge To Transition Layer\",\"true\",\"Composition\"),true)\r\n\r\nif self.useNasSmb then\r\n    self.audioPath = self.smbPath\r\n    self.videoPath = self.smbPath\r\n    self.imagePath = self.smbPath\r\n    self.otherPath = self.smbPath\r\nelse\r\n    self.audioPath = pixc.getRoot().Utils.Filesystem.normalizePath(self.contentDirectory..\"/audio\")\r\n    self.videoPath = pixc.getRoot().Utils.Filesystem.normalizePath(self.contentDirectory..\"/video\")\r\n    self.imagePath = pixc.getRoot().Utils.Filesystem.normalizePath(self.contentDirectory..\"/image\")\r\n    self.otherPath = pixc.getRoot().Utils.Filesystem.normalizePath(self.contentDirectory..\"/other\")\r\nend\r\n\r\n\r\nself.udpComPort = 0 --tonumber(self.helper:getProperty(\"Downloader UDP Port\",\"64000\"))\r\nself.hideDownloaderConsole = self.helper:getProperty(\"Hide Downloader Console\",\"true\")\r\n\r\nself.layerPlayName = self.helper:getProperty(\"Content Layer Name\", \"Layer Play\",\"Timeline\")\r\nself.layerBlendName = self.helper:getProperty(\"Transition Layer Name\", \"Layer Blend\",\"Transition\")\r\nself.consoleHideCode = 0;\r\nif(self.hideDownloaderConsole == false or self.hideDownloaderConsole == \"false\") then\r\n\tself.consoleHideCode = 3\r\nend\r\nlocal dsm = self.helper:getProperty(\"Delete Unscheduled Media\",\"Never\",\"Content\")\r\nif dsm == \"Never\" then\r\n\tself.downloaderCleanMode = false\r\nelse\r\n\tself.downloaderCleanMode = true\r\nend\r\nself.removeAssetsMode = self.helper:getProperty(\"Remove Assets Mode\",\"Never\",\"Content\")\r\nif(self.removeAssetsMode == \"Automatically At Time\") then\r\n\tself.removeAssetsMode = \"Dayli\"\r\nend\r\nif( self.removeAssetsMode == \"Dayli\") then\r\n\tself.removeAssetTime = self.Helper.getRemoveTime()\r\n\tif(self.removeAssetTime == nil) then\r\n\t\tself.removeAssetsMode = \"Never\"\r\n\t\tself.Errorhelper.addError(\"Invalid Time For Remove Assets Automatically At Time -> Disabled\",\"warning\")\r\n\tend\r\nend\r\nif(self.useNasSmb == true) then\r\n\tself.log(1,\"SMB Info: enabled \",self.smbPath)\r\nelse\r\n\t--self.log(1,\"SMB Info: disabled\")\r\nend\r\nself.reservedAction = {};\r\nself.reservedScheduleEvent = {};\r\nself.scheduleName = \"Main\"..self()\r\n--self.log(1,self()..\" \"..self.scheduleName)\r\nself.playingstatus = {}\r\nself.playingstatus.mode = \"none\"\r\nself.playingstatus.state = \"none\"\r\nself.playingstatus.currentMainTimelineMain = true\r\nself.schedUpdateInterval = self.helper:getProperty(\"Scheduler Update Interval\",\"30s\",\"Expert\")\r\nself.schedUpdateInterval = self.parseTimestring(self.schedUpdateInterval)\r\nif self.schedUpdateInterval == nil or self.schedUpdateInterval < 2 then\r\n\tself.Errorhelper.addError(\"Invalid Scheduler Update Interval\",\"error\")\r\n\tself.uninit()\r\n\treturn\r\nend\r\nself.heartbeatCycleSec = self.helper:getProperty(\"Heartbeat Interval\",\"3s\",\"Expert\");\r\nself.heartbeatCycleSec = self.parseTimestring(self.heartbeatCycleSec)\r\nif self.heartbeatCycleSec == nil or self.heartbeatCycleSec < 0.2 then\r\n\tself.Errorhelper.addError(\"Invalid Heartbeat Interval\",\"error\")\r\n\tself.uninit()\r\n\treturn\r\nend\r\nlocal maxMaintenanceS = tonumber(self.helper:getProperty(\"Max Maintenance (s)\",\"1800\",\"Expert\"))\r\nself.maxMaintenanceCounter = maxMaintenanceS / self.heartbeatCycleSec\r\nif self.maxMaintenanceCounter < 1 then\r\n\tself.maxMaintenanceCounter = 1\r\nend\r\nself.schedUpdateByHeartbeat = true --self.helper.toBool(self.helper:getProperty(\"Use Heartbeat Timer for update\",\"true\"),true)\r\n\r\nif(self.schedUpdateByHeartbeat == true) then\r\n\tself.updateCounter = self.schedUpdateInterval/self.heartbeatCycleSec\r\n\r\nend\r\n\r\nself.isaacAdapterIP = pixc.getRoot().Utils.Network.convertLocalAdapterEntry(self.helper:getProperty(\"Network Adapter\",\"\",\"Expert\"),true,true)\r\nself.heartbeatTriggerActive = false\r\nself.schdedulerTriggerActive = false\r\nself.transitionTemplates ={}\r\nif self.compositionsEnabled == true then\r\n\tself.Composition.registerHelper()\r\n\tself.Composition.loadCompositionTemplates()\r\nend\r\n\r\nself.Helper.triggerHeartbeat()\r\n\r\nself.apiKey = \"\";\r\n--self.network:configureUdp(\r\n--\t\"127.0.0.1\",\r\n--\t1024,\r\n--\t\"127.0.0.1\",\r\n--\tself.udpComPort ,\r\n--\tfunction (handle, data) self.ContentHandling.handleContentCallbackInfo(data) end,\r\n--\tfunction(handle, error) self.log(1,\"closeCallback: \"..error) end)\r\n--if self.udpComPort > 0 then\r\n--\tself.network:start()\r\n--end\r\n\r\nif self.useTimecode == false then\r\n\tself.TimelineMain().setSmpteMode(0)\r\nend\r\n\r\nself.maintencecount = nil\r\nself.UI.Maintenance(false,true)\r\nself.Schedule.getSchedule()\r\nself.Player.stopPlayInstant(true)\r\nself.Player.initTimelineStatus();\r\nself.timelineStatus.objects = {}\r\n--self.Player.cleanTimeline(2)\r\nlocal tl = self.TimelineMain()\r\nlocal fps = tl.getFps()\r\nself.Player.cleanTimeline(tl,\"init\");\r\n--self.Events.getEvents()\r\n--self.Helper.triggerGetCalendarEntries()\r\n--self.scheduleUpdateActive = true\r\nself.Player.getPlayerInfo()\r\nself.Player.syncDefaultEvents()\r\nif self.reinitOnSystemTimeChange == true then\r\n\tlocal res, hdl =  pcall(Utils.Timer.registerSystemtimeChangedCallback,function() self.Player.systemTimeChanged() end)\r\n\tif( res == false) then\r\n\t\tself.reinitOnSystemTimeChange = false\r\n\t\tself.log(1,\"Reinit on SystemtimeChanged disabled, not supported in this Pixera version\")\r\n\telse\r\n\t\tself.stcHandle = hdl\r\n\tend\r\nend\r\n",
   "kind": "func",
   "name": "init",
   "path": "ISAACPlayer24H.init"
  },
  {
   "body": "if self.stcHandle ~= nil then\r\n\tUtils.Timer.removeSystemtimeChangedCallback(self.stcHandle)\r\nend\r\nself.stop = true\r\nself.UI.started(false,true)\r\nself.UI.HeartbeatOK(2,true)\r\nself.Errorhelper.addError(\"Uninit called\",\"warning\")\r\n--self.Errorhelper.clearErrors()\r\nself.Player.cleanTimeline(1)\r\nself.Player.stopPlayInstant(true)\r\n--self.UI.connectionState(false)\r\nself.ContentHandling.cancelDownload()\r\nif self.intervalHeartbeatHandle ~= nil then\r\nlocal success = pcall(function() return pixc.getRoot().Utils.Timer.clearTimeout(self.intervalHeartbeatHandle) end)\r\n\tself.intervalHeartbeatHandle = nil\r\nend\r\nif self.intervalScheduleHandle ~= nil then\r\nlocal success = pcall(function() return pixc.getRoot().Utils.Timer.clearTimeout(self.intervalScheduleHandle) end)\r\n\tself.intervalScheduleHandle = nil\r\nend\r\nself.timelineStatus = nil\r\nif self.protocol ~= nil then \r\n\tself.protocol:close()\r\n\tself.protocol = nil\r\nend\r\nself.helper = nil\r\nif self.network ~= nil then\r\n\tself.network:close()\r\n\tself.network = nil\r\nend\r\n\r\n",
   "kind": "func",
   "name": "uninit",
   "path": "ISAACPlayer24H.uninit"
  },
  {
   "body": "if self.protocol == nil then self.log(1,\"not initialized\") return end\r\nlocal parameter = {}\r\nparameter[\"subsystemExternalId\"] = self.externalId\r\nlocal url = self.url..\"/api/v1/events\"\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\n--self.log(1,url)\r\nlocal success, code, headerDict, content = self.protocol:httpGet(url,parameter)\r\nif(success) then\r\n\t--self.log(1,code)\r\n\t--self.log(1,content)\r\nend\r\n",
   "kind": "func",
   "name": "listEvents",
   "path": "ISAACPlayer24H.listEvents",
   "slotStyle": "hidden"
  },
  {
   "body": "\r\nif self.protocol == nil then self.log(1,\"not initialized\") return end\r\nif self._Maintenance == true then\r\n\tif self.maintencecount == nil then\r\n\t\tself.Errorhelper.addError(\"Maintenance active\",\"info\")\r\n\t\tself.maintencecount = 0\r\n\telse\r\n\t\tself.maintencecount = self.maintencecount  +1\r\n\tend\r\n\t--pixc.log(self.maintencecount ,self.maxMaintenanceCounter)\r\n\tif(self.maintencecount > self.maxMaintenanceCounter) then\r\n\t\tself.UI.Maintenance(false,true)\r\n\t\tself.maintencecount = nil\r\n\t\tself.Errorhelper.addError(\"Maintenance deactivated by Time\",\"info\")\r\n\r\n\telse\r\n\t\tself.heartbeatTriggerActive = false\r\n\t\tself.Helper.triggerHeartbeat()\r\n\t\treturn\r\n\tend\r\nelse\r\n\tif self.maintencecount ~=  nil then\r\n\t\tself.maintencecount = nil\r\n\t\tself.Errorhelper.addError(\"Maintenance deactivated\",\"info\")\r\n\tend\r\nend\r\nlocal parameter = {}\r\nparameter[\"id\"] = self.externalId\r\nlocal url = self.url..\"/api/v1/subsystems/\"..self.externalId..\"/heartbeat\"\r\n--self.log(1,url)\r\nlocal success, code, headerDict, content = self.protocol:httpPut(url,nil,parameter,nil)\r\nif(success) then\r\n\tif(code == 201 or code == 200) then\r\n\t\t--self.UI.connectionState(true)\r\n\t\tif self.heartbeatErrorCount  == nil then\r\n\t\t\tself.heartbeatErrorCount = 0\r\n\t\t\tself.Errorhelper.addError(\"Heartbeat OK \"..self.codeToString(code),\"info\")\r\n\t\telse \r\n\t\t\tif self.heartbeatErrorCount > 0 then\r\n\t\t\t\tself.heartbeatErrorCount = 0\r\n\t\t\t\tself.Errorhelper.addError(\"Heartbeat OK after error \"..self.codeToString(code),\"info\")\r\n\t\t\tend\r\n\t\tend\r\n    \t\r\n        if self.enableInstantPlay == true then\r\n\t\t\tself.Helper.requireJson();\r\n\t\t\tlocal msgParsed = self.jsonlib.decode(content)\r\n\t\t\t\r\n\t\t\tif msgParsed ~= nil and msgParsed.message ~= nil then\r\n\t\t\t\t--self.log(1,\"heartbeat\",content)\r\n\t\t\t\tself.Player.executeHeartbeatMessage(msgParsed.message)\r\n\t\t\tend\r\n        end\r\n\telse\r\n\t\tif self.heartbeatErrorCount  == nil then\r\n\t\t\tself.heartbeatErrorCount = 1\r\n\t\t\tself.Errorhelper.addError(\"Heartbeat failed (\"..self.heartbeatErrorCount..\") with \"..self.codeToString(code),\"error\")\r\n\t\telse \r\n\t\t\tif self.heartbeatErrorCount  < 1 then\r\n\t\t\t\tself.heartbeatErrorCount = 1\r\n\t\t\t\tself.Errorhelper.addError(\"Heartbeat failed (\"..self.heartbeatErrorCount..\") with \"..self.codeToString(code),\"error\")\r\n\t\t\telse\r\n\t\t\t\tself.heartbeatErrorCount = self.heartbeatErrorCount +1\r\n\t\t\t\tif self.heartbeatErrorCount > 1 and (math.fmod(self.heartbeatErrorCount,15) == 0) then\r\n\t\t\t\t\tself.Errorhelper.addError(\"Heartbeat failed (\"..self.heartbeatErrorCount..\") with \"..self.codeToString(code),\"error\")\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\t\r\n\tend\r\nelse\r\n\tself.Errorhelper.addError(\"Heartbeat failed \"..self.codeToString(code),\"error\")\r\n\t--self.UI.connectionState(false)\r\nend\r\nif(self.heartbeatErrorCount > 0) then\r\n\tself.UI.HeartbeatOK(2,true)\r\nelse\r\n\tself.UI.HeartbeatOK(1,true)\r\nend\r\nif self.schedUpdateByHeartbeat == true then \r\n\tif self.scheduleUpdateDone == true then\r\n\t\tself.scheduleUpdateCounter = 0;\r\n\t\tself.scheduleUpdateDone = false;\r\n\t\tself.scheduleUpdateActive = false\r\n\telse\r\n\t\tif self.scheduleUpdateActive == false then\r\n\t\t\tself.scheduleUpdateCounter = self.scheduleUpdateCounter +1;\r\n\t\t\tif self.scheduleUpdateCounter > self.updateCounter then\r\n\t\t\t\tself.scheduleUpdateActive = true\r\n\t\t\t\tself.Player.getPlayerInfo()\r\n\t\t\tend\r\n\t\tend \r\n\tend\r\nend\r\n\t\r\nself.heartbeatTriggerActive = false\r\nself.Helper.triggerHeartbeat()\r\nif self.schedUpdateByHeartbeat == nil or self.schedUpdateByHeartbeat == false then\r\n\tif self.triggerHandle == nil then\r\n\t\tif(self.triggerNilCount == nil ) then\r\n\t\t\tself.triggerNilCount = 0;\r\n\t\tend\r\n\t\tself.triggerNilCount = self.triggerNilCount + 1;\r\n\t\tif(self.timoutResetMin ~= nil ) and self.triggerNilCount > (self.timoutResetMin*60 / self.heartbeatCycleSec ) then\r\n\t\t\tself.Errorhelper.addError(\"Trigger was to long nil -> reactivated by heartbeat\",\"warning\")\r\n\t\t\tself.Player.registerTrigger();\r\n\t\tend\r\n\telse\r\n\t\tself.triggerNilCount = 0;\r\n\tend\r\nend\r\n\r\nself.Player.updateUI()\r\n",
   "kind": "func",
   "name": "heartbeat",
   "path": "ISAACPlayer24H.heartbeat"
  },
  {
   "body": "local data = {}\r\ndata.url = self.url\r\ndata.externalId = self.externalId\r\ndata.externalIdSchedule = self.externalIdSchedule \r\ndata.mappedContentFolder  = self.mappedContentFolder \r\ndata.mediaOverlayContentFolder = self.mediaOverlayContentFolder \r\ndata.contentDirectory = self.contentDirectory\r\ndata.dissolveInMs = self.dissolveInMs \r\ndata.dissolveHighMs = self.dissolveHighMs \r\ndata.dissolveHighOffsetMs = self.dissolveHighOffsetMs\r\ndata.dissolveOutMs = self.dissolveOutMs\r\ndata.maximumBridgeGapS  = self.maximumBridgeGapS \r\ndata.applyDisolveOnVideo  = self.applyDisolveOnVideo \r\ndata.transitionMode = self.transitionMode \r\ndata.mediaOverlayFixedResourceName = self.mediaOverlayFixedResourceName\r\ndata.audioPath = self.audioPath\r\ndata.videoPath = self.videoPath\r\ndata.imagePath = self.imagePath \r\ndata.otherPath = self.otherPath\r\ndata.layerPlayName = self.layerPlayName\r\ndata.layerBlendName = self.layerBlendName \r\ndata.schedUpdateInterval = self.schedUpdateInterval\r\ndata.useNasSmb = self.useNasSmb\r\ndata.smbPath = self.smbPath\r\ndata.limitVideoBlendDuration = self.limitVideoBlendDuration\r\nreturn data\r\n",
   "kind": "func",
   "name": "getConfig",
   "path": "ISAACPlayer24H.getConfig",
   "slotStyle": "hidden"
  },
  {
   "elems": [
    {
     "body": "if self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nif self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\nlocal obj = {};\r\nobj.command = self.jsonlib.encode(command);\r\nobj.description = description\r\nobj.displayName = name\r\nobj.subsystemExternalId = self.externalId\r\nobj.active = true\r\n\r\nstr = self.jsonlib.encode(obj);\r\n--self.log(1,str);\r\n\r\n\r\n\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\nlocal parameter = nil\r\n\r\nlocal url = self.url..\"/api/v1/events\"\r\n--self.log(1,url)\r\nlocal success, code, headerDict, content = self.protocol:httpPost(url,str,parameter,customHeader)\r\nif(success) then\r\n\tif(code == 200) then\r\n\t\r\n\tend\r\n\r\n\t--self.log(1,code)\r\n\t--self.log(1,content)\r\n\t--self.Events.getEvents()\r\nend\r\n",
     "kind": "func",
     "name": "addEvent",
     "params": [
      {
       "name": "name",
       "type": "string"
      },
      {
       "name": "description",
       "type": "string"
      },
      {
       "name": "command",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.Events.addEvent"
    },
    {
     "body": "if self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nif self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\nlocal obj = {};\r\nif command ~=nil then \r\n   obj.command = self.jsonlib.encode(command);\r\nend\r\nif description ~= nil then\r\n    obj.description = description\r\nend\r\nif name ~= nil then\r\n\tobj.displayName = name\r\nend\r\nobj.subsystemExternalId = self.externalId\r\nobj.active = true\r\n\r\nstr = self.jsonlib.encode(obj);\r\n--self.log(1,str);\r\n\r\n\r\n\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\nlocal parameter = nil\r\n\r\nlocal url = self.url..\"/api/v1/events/\"..id\r\n--self.log(1,url)\r\nlocal success, code, headerDict, content = self.protocol:httpPut(url,str,parameter,customHeader)\r\nif(success) then\r\n\t--self.log(1,code)\r\n\t--self.log(1,content)\r\n\tself.Events.getEvents()\r\nend\r\n",
     "kind": "func",
     "name": "updateEvent",
     "params": [
      {
       "name": "id",
       "type": "string"
      },
      {
       "name": "name",
       "type": "string"
      },
      {
       "name": "description",
       "type": "string"
      },
      {
       "name": "command",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.Events.updateEvent"
    },
    {
     "body": "--\nif self.protocol == nil then self.log(1,\"not initialized\") return end\n--\nif self.jsonlib == nil then\n\tself.jsonlib = require \"json\" \nend\nlocal parameter = {}\nparameter[\"subsystemExternalId\"] = self.externalId\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\n--local parameter = nil\nlocal url = self.url..\"/api/v1/events\"\n--self.log(1,url,self.externalId)\nlocal success, code, headerDict, content = self.protocol:httpGet(url,parameter)\nif(success) then\n\t--self.log(1,code)\n\t--self.log(1,content)\n\tif( code == 200) then\n\t\tself.events = self.jsonlib.decode(content)\n\t\tself.eventKeys = {}\n\t\tfor k,v in ipairs(self.events or {}) do\n\t\t\tself.eventKeys[v._id] = true\n\t\tend\n\t\tself.Events.updateSchedulerActions();\n\telse\n\t\tself.log(1,self()..\" getEvents failed with code\", code)\n\tend\nend\n",
     "kind": "func",
     "name": "getEvents",
     "path": "ISAACPlayer24H.Events.getEvents"
    },
    {
     "body": "--\n--\nif id == nil then return end\nif self.protocol == nil then self.log(1,\"not initialized\") return end\n--\nif self.jsonlib == nil then\n\tself.jsonlib = require \"json\" \nend\nlocal parameter = {}\nparameter[\"subsystemExternalId\"] = self.externalId\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\nlocal parameter = nil\nlocal url = self.url..\"/api/v1/events/\"..math.tointeger(id)\n--self.log(1,url)\nlocal success, code, headerDict, content = self.protocol:httpDelete(url,parameter)\nif(success) then\n\t--self.log(1,code)\n\t--self.log(1,content)\n\tself.events = self.jsonlib.decode(content)\nend\nself.Events.getEvents()\n",
     "kind": "func",
     "name": "removeEventById",
     "params": [
      {
       "name": "id",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.Events.removeEventById"
    },
    {
     "body": "--\nself.Events.getEvents()\nif self.events == nil then return nil end\nfor k,v in pairs(self.events) do\n\t--self.log(1,self()..\"\",k,v.displayName,v._id,name)\n\tif v.displayName == name then\n\t\treturn v._id\n\tend\nend\nreturn nil\n",
     "kind": "func",
     "name": "nameToId",
     "params": [
      {
       "name": "name",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.Events.nameToId"
    },
    {
     "body": "--\nself.Events.removeEventById(self.Events.nameToId(name))\r\n",
     "kind": "func",
     "name": "removeEventByName",
     "params": [
      {
       "name": "name",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.Events.removeEventByName"
    },
    {
     "body": "--\nif self.jsonlib == nil then\n\tself.jsonlib = require \"json\" \nend\nlocal currentActions = self.schedule.getActions()\nlocal currentActionToDeleteMap = {}\n--self.log(1,\"CurrentActions\",pixcCommon.toJson(currentActions))\nfor k,v in pairs(currentActions) do\n\tif(self.Events.isReservedAction(k)) then\n\t\n\telse\n    \tcurrentActionToDeleteMap[k] = true\n\tend\nend\nfor k,v in ipairs(self.events) do\n\tif currentActionToDeleteMap[v._id] == nil then\n\t\tlocal action = v._id\n\t\tlocal jsonStr = v.command\n\t\t--self.log(1,v.command,v.displayName)\n\t\tif v.command == nil or v.displayName == nil or v.displayName == \"\" then\n\t\t\tself.Events.removeEventById(v._id)\n\t\telse\n\t\t\tlocal json = self.jsonlib.decode(jsonStr)\n\t\t\tif type(table) == 'table' and json[1] ~= nil then\n\t\t\t\tself.schedule.addAction(v._id..\"\", json)\n\t\t\telse\n\t\t\t\tself.Events.removeEventById(v._id)\n\t\t\tend\n\t\tend\t\n\telse\n\t\tcurrentActionToDeleteMap[v._id] = false\n\tend\nend\nfor k,v in pairs(currentActionToDeleteMap) do\n\tif v == true then\n\t\tself.schedule.removeAction(k)\n\tend\nend\nself.Schedule.getCalendarScheduledItems()\n",
     "kind": "func",
     "name": "updateSchedulerActions",
     "path": "ISAACPlayer24H.Events.updateSchedulerActions"
    },
    {
     "body": "return self.reservedAction[action] ~= nil;\r\n",
     "kind": "func",
     "name": "isReservedAction",
     "params": [
      {
       "name": "action",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.Events.isReservedAction",
     "result": {
      "name": "result",
      "type": "bool"
     }
    }
   ],
   "kind": "ns",
   "name": "Events"
  },
  {
   "elems": [
    {
     "body": "--\nself.Helper.updateApiKeyHeader();\r\n",
     "kind": "func",
     "name": "getToken",
     "path": "ISAACPlayer24H.Helper.getToken"
    },
    {
     "body": "--\r\nself.apiKeyHeader = \"X-API-Key: \"..self.apiKey;\r\n",
     "kind": "func",
     "name": "updateApiKeyHeader",
     "path": "ISAACPlayer24H.Helper.updateApiKeyHeader"
    },
    {
     "body": "if self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\n",
     "kind": "func",
     "name": "requireJson",
     "path": "ISAACPlayer24H.Helper.requireJson"
    },
    {
     "body": "if self.heartbeatTriggerActive == true then return end\r\nself.heartbeatTriggerActive = true\r\nlocal success, instance = pcall(function() return pixc.getRoot().Utils.Timer.setTimeout(function() self.heartbeat(); end, self.heartbeatCycleSec*1000 ) end)\r\nif success then\r\n\tself.intervalHeartbeatHandle = instance\r\nend\r\n",
     "kind": "func",
     "name": "triggerHeartbeat",
     "path": "ISAACPlayer24H.Helper.triggerHeartbeat"
    },
    {
     "body": "if self.schdedulerTriggerActive == true then return end\r\nself.schdedulerTriggerActive = true\r\nlocal success, instance = pcall(function() return pixc.getRoot().Utils.Timer.setTimeout(function() self.Schedule.getCalendarScheduledItems(); end, self.schedUpdateInterval*1000) end)\r\nif success then\r\n\tself.intervalScheduleHandle = instance\r\nend\r\n",
     "kind": "func",
     "name": "triggerGetCalendarEntries",
     "path": "ISAACPlayer24H.Helper.triggerGetCalendarEntries"
    },
    {
     "elems": [
      {
       "body": "--\r\nif self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nself.Helper.requireJson()\r\nlocal obj = {}\r\nobj.description = \"Description of \".. name\r\nobj.type = type\r\nif value ~= nil then\r\n\tobj.lastValue = value\r\nend\r\nobj.displayName = name\r\nobj.externalRef = name\r\nobj.subsystemExternalId = self.externalId\r\n\r\nstr = self.jsonlib.encode(obj);\r\n--self.log(1,str);\r\n\r\n\r\n\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\nlocal parameter = nil\r\n\r\nlocal url = self.url..\"/api/v1/variables\"\r\n--self.log(1,url)\r\nlocal success, code, headerDict, content = self.protocol:httpPost(url,str,parameter,customHeader)\r\nif(success) then\r\n\t--self.log(1,code)\r\n\t--self.log(1,content)\r\nend\r\n",
       "kind": "func",
       "name": "addVariable",
       "params": [
        {
         "name": "name",
         "type": "string"
        },
        {
         "name": "value",
         "type": "string"
        },
        {
         "name": "type",
         "type": "string"
        }
       ],
       "path": "ISAACPlayer24H.Helper.VariableHelper.addVariable"
      },
      {
       "body": "--\r\nif id == nil then return end\r\nif self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nif self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\nlocal parameter = {}\r\n\r\nlocal parameter = nil\r\nlocal idStr = id\r\nif type(id) == \"number\" then\r\n\tidStr = math.tointeger(id)\r\nend\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\nlocal url = self.url..\"/api/v1/variables/\"..idStr\r\n--self.log(1,url)\r\nlocal success, code, headerDict, content = self.protocol:httpDelete(url,parameter,customHeader)\r\nif(success) then\r\n\t--self.log(1,code)\r\n\t--self.log(1,content)\r\nend\r\n",
       "kind": "func",
       "name": "removeVariable",
       "params": [
        {
         "name": "id",
         "type": "string"
        }
       ],
       "path": "ISAACPlayer24H.Helper.VariableHelper.removeVariable"
      },
      {
       "body": "--\r\nif self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nself.Helper.requireJson()\r\nlocal obj = {}\r\nif value ~= nil then\r\n\tobj.value = value\r\nend\r\nstr = self.jsonlib.encode(obj);\r\nself.log(1,str);\r\n\r\n\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\nlocal parameter = nil\r\n--parameter[\"id\"] = name\r\nlocal url = self.url..\"/api/v1/subsystems/\"..self.externalId..\"/variables/\"..name..\"/lastValue\"\r\n--local url = self.url..\"/api/v1/variables/\"..\"21\"..\"/value\"\r\nself.log(1,url)\r\nlocal success, code, headerDict, content = self.protocol:httpPost(url,str,parameter,customHeader)\r\nif(success) then\r\n\t--self.log(1,code)\r\n\t--self.log(1,content)\r\nend\r\n",
       "kind": "func",
       "name": "setVariable",
       "params": [
        {
         "name": "name",
         "type": "string"
        },
        {
         "name": "value",
         "type": "string"
        }
       ],
       "path": "ISAACPlayer24H.Helper.VariableHelper.setVariable"
      },
      {
       "body": "if self.Data.VariableData == nil then\r\n\treturn\r\nend\r\n\r\nlocal variables = self.Data.VariableData.Variables\r\nlocal templateNumber = [[\r\n\t{\r\n\t\t\"name\": \"##Name##\",\r\n\t\t\"subPath\" : \"##Path##\",\r\n\t\t\"kind\": \"fn\",\r\n\t\t\"attKind\": \"standard\",\r\n\t\t\"slotStyle\": \"leftIn;rightNone;triggerHidden\",\r\n\t\t\"params\": [\r\n\t\t\t{\r\n\t\t\t\t\"name\": \"value\",\r\n\t\t\t\t\"type\": \"int\"\r\n\t\t\t}\r\n\t\t],\r\n\t\t\"result\": {\r\n\t\t},\r\n\t\t\"body\": \"if value == nil then pixcCommon.execAttribute(false, self.Variables.VAR_int__##Name##, self.Variables.VAR_int__##Name##, true); return; end \\r\\n self.Helper.VariableHelper.setVariableSubsystem('##Name##',value) ; self.Variables.VAR_int__##Name## = pixcCommon.execAttribute(false, self.Variables.VAR_int__##Name##, value, true);\"\r\n\t}\r\n]]\r\n\r\nlocal templateString = [[\r\n\t{\r\n\t\t\"name\": \"##Name##\",\r\n\t\t\"subPath\" : \"##Path##\",\r\n\t\t\"kind\": \"fn\",\r\n\t\t\"attKind\": \"standard\",\r\n\t\t\"slotStyle\": \"leftIn;rightNone;triggerHidden\",\r\n\t\t\"params\": [\r\n\t\t\t{\r\n\t\t\t\t\"name\": \"value\",\r\n\t\t\t\t\"type\": \"string\"\r\n\t\t\t}\r\n\t\t],\r\n\t\t\"result\": {\r\n\t\t},\r\n\t\t\"body\": \"if value == nil then pixcCommon.execAttribute(false, self.Variables.VAR_int__##Name##, self.Variables.VAR_int__##Name##, true); return; end \\r\\n self.Helper.VariableHelper.setVariableSubsystem('##Name##',value) ; self.Variables.VAR_int__##Name## = pixcCommon.execAttribute(false, self.Variables.VAR_int__##Name##, value, true);\"\r\n\t}\r\n]]\r\nlocal res = '[';\r\nlocal nrVariables = 0;\r\n\r\nfor n, v in pairs(variables or {}) do\r\n\tnrVariables = nrVariables+1\r\nend\r\nlocal count = 1\r\nif nrVariables == 0 then\r\n\tlocal tmod = templateNumber;\r\n\tlocal c;\r\n\ttmod, c = string.gsub(tmod,\"##Name##\", \"\")\r\n\ttmod, c = string.gsub(tmod,\"##Path##\", \"Variables\")\r\n\tres = res..tmod;\r\nelse\r\n\tfor n, v in pairs(variables) do\r\n\t\tlocal tmod = templateNumber;\r\n\t\tif v.type == \"string\" then\r\n\t\t\ttmod = templateString\r\n\t\tend\r\n\r\n\t\tlocal c;\r\n\r\n\t\ttmod, c = string.gsub(tmod,\"##Name##\", n)\r\n\t\ttmod, c = string.gsub(tmod,\"##Path##\", \"Variables\")\r\n\t\tres = res..tmod;\r\n\t\tif nrVariables ~= count then\r\n\t\t\tres = res..','\r\n\t\tend\r\n\t\tcount = count+1\r\n\tend\r\nend\r\n\r\nres = res..']'\r\n--self.log(1,res)\r\nreturn res;\r\n",
       "kind": "func",
       "name": "getDescription",
       "path": "ISAACPlayer24H.Helper.VariableHelper.getDescription"
      },
      {
       "body": "self().dynamicRebuildFromDescriptions(self.Helper.VariableHelper.getDescription(), \"\", \"(.*)\")\r\n",
       "kind": "func",
       "name": "updateProps",
       "path": "ISAACPlayer24H.Helper.VariableHelper.updateProps"
      },
      {
       "body": "--\r\nif self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nself.Helper.requireJson()\r\n\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\nlocal parameter = {}\r\nparameter[\"subsystemExternalId\"] = self.externalId\r\nlocal url = self.url..\"/api/v1/variables\"\r\n--self.log(1,url)\r\nlocal success, code, headerDict, content = self.protocol:httpGet(url,parameter,customHeader)\r\nif(success) then\r\n\t--self.log(1,code)\r\n\t--self.log(1,content)\r\n\tlocal vData = self.jsonlib.decode(content);\r\n\treturn vData;\r\nend\r\n",
       "kind": "func",
       "name": "getVariables",
       "path": "ISAACPlayer24H.Helper.VariableHelper.getVariables"
      },
      {
       "body": "local onlineV = self.Helper.VariableHelper.getVariables();\r\nif(self.Data.VariableData.Variables == nil) then\r\n\treturn\r\nend\r\nfor _,v in ipairs(onlineV) do\r\n\t--self.log(1,\"onlineV\",v.displayName)\r\n\tif self.Data.VariableData.Variables[v.displayName] == nil then\r\n\t\t--self.log(1,\"remove\",v.displayName,v._id)\r\n\t\tself.Helper.VariableHelper.removeVariable(v._id);\r\n\tend\r\nend\r\n\r\nonlineV = self.Helper.VariableHelper.getVariables();\r\nif onlineV ~= nil then\r\n\tfor k, v in pairs(self.Data.VariableData.Variables) do\r\n\t\tlocal found = false;\r\n\t\tfor _,vO in ipairs(onlineV) do\r\n\t\t\tif vO.externalRef == k then\r\n\t\t\t\tfound = true\r\n\t\t\tend\r\n\t\tend\r\n\t\tif found == false then\r\n\t\t\tself.Helper.VariableHelper.addVariable(k,nil,v.type)\r\n\t\tend\r\n\tend\r\n\r\nend\r\n",
       "kind": "func",
       "name": "syncVariables",
       "path": "ISAACPlayer24H.Helper.VariableHelper.syncVariables"
      },
      {
       "body": "--\r\nif name == nil or value == nil or self.externalId == nil then\r\n\treturn\r\nend\r\nif self.protocol == nil then self.log(1,\"not initialized\") return end\r\n\r\nlocal str = value..\"\"\r\n\r\nlocal customHeader={\"Content-Type: text/plain\",apiKeyHeader}\r\nlocal parameter = nil\r\nlocal url = self.url..\"/api/v1/subsystems/\"..self.externalId..\"/variables/\"..name..\"/lastValue\"\r\n--self.log(1,url)\r\nlocal success, code, headerDict, content = self.protocol:httpPut(url,str,parameter,customHeader)\r\nif(success) then\r\n\tif code ~= 200 then\r\n\t\tself.log(1,\"Variable update failed\",name,value,code)\r\n\tend\r\nelse\r\n\tself.log(1,\"Variable update failed\",name,value,code)\r\nend\r\n",
       "kind": "func",
       "name": "setVariableSubsystem",
       "params": [
        {
         "name": "name",
         "type": "string"
        },
        {
         "name": "value",
         "type": "string"
        }
       ],
       "path": "ISAACPlayer24H.Helper.VariableHelper.setVariableSubsystem"
      }
     ],
     "kind": "ns",
     "name": "VariableHelper"
    },
    {
     "body": "if self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\nif(object == nil) then \r\n\tself.log(1,tag,\"nil\")\r\nend\r\nself.log(1,tag,self.jsonlib.encode(object));\r\n",
     "kind": "func",
     "name": "logAsJson",
     "params": [
      {
       "name": "tag",
       "type": "string"
      },
      {
       "name": "object",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.Helper.logAsJson"
    },
    {
     "body": "return {\"Cut\",\"Media Overlay Random\",\"Media Overlay Fixed\",\"Expert\"}\r\n",
     "kind": "func",
     "name": "transitionMode",
     "path": "ISAACPlayer24H.Helper.transitionMode"
    },
    {
     "body": "return { \"Never\", \"Instant\",\"Automatically At Time\"}\r\n",
     "kind": "func",
     "name": "assetCleanMode",
     "path": "ISAACPlayer24H.Helper.assetCleanMode"
    },
    {
     "body": "\r\nlocal now = pixc.getRoot().Utils.Timer.now();\r\nlocal s = pixc.getRoot().Utils.Timer.toStringLocal(now)\r\n\r\nlocal year, month, day, hour, min,sec = s:match(\"(%d+)-(%d+)-(%d+) (%d+):(%d+):(%d+)\")\r\nreturn  tonumber(hour), tonumber(min),tonumber(sec);\r\n",
     "kind": "func",
     "name": "getTimeNowLocal",
     "path": "ISAACPlayer24H.Helper.getTimeNowLocal"
    },
    {
     "body": "local t = self.helper:getProperty(\"Delete Unscheduled Media Time (24h) (hh:mm)\",\"02:00\",\"Content\")\r\nlocal removeTimeH, removeTimeM =t:match(\"(%d+):(%d+)\")\r\nif(removeTimeH == nil or removeTimeM == nil or tonumber(removeTimeH) > 23 or tonumber(removeTimeH) < 0 or tonumber(removeTimeM) >59 or tonumber(removeTimeM) < 0) then\r\n\treturn nil\r\nend\r\nself.removeTime = tonumber(removeTimeH)*60 + tonumber(removeTimeM);\r\nif self.removeTime < 5 then self.removeTime = 5 end\r\nif self.removeTime > 23*60+55 then self.removeTime = 23*60+55 end\r\nreturn self.removeTime;\r\n",
     "kind": "func",
     "name": "getRemoveTime",
     "path": "ISAACPlayer24H.Helper.getRemoveTime"
    },
    {
     "body": "return  {\"Disabled\",\"Enabled\",\"Enabled and Stop Timelines\"}\r\n",
     "kind": "func",
     "name": "instantplayModes",
     "path": "ISAACPlayer24H.Helper.instantplayModes"
    },
    {
     "body": "return {\"Stills\",\"Stills & Video\"}\r\n",
     "kind": "func",
     "name": "getApplyTransitionDurationModes",
     "path": "ISAACPlayer24H.Helper.getApplyTransitionDurationModes"
    },
    {
     "body": "return {\"Never\",\"Automatically\"}\r\n",
     "kind": "func",
     "name": "getDelUnscheduledMediaModes",
     "path": "ISAACPlayer24H.Helper.getDelUnscheduledMediaModes"
    },
    {
     "body": "if(self.log == nil) then\r\n\tself.log = function(level,...)\r\n\t\tif (level == nil) then return end\r\n\t\tif (self.logLevel == nil) then self.logLevel = 1 end\r\n\t\tlocal now = pixc.getRoot().Utils.Timer.now();\r\n\t\tlocal timeStringNow = pixc.getRoot().Utils.Timer.toStringLocal(now)\r\n\t\tif type(level) ~= \"number\" then\r\n\t\t\tpixc.log(level,...)\r\n\t\telse \r\n\t\t\tif level  <= self.logLevel  then \r\n\t\t\t\tpixc.log(self()..\"\",timeStringNow,...)\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\n",
     "kind": "func",
     "name": "registerLog",
     "path": "ISAACPlayer24H.Helper.registerLog"
    },
    {
     "body": "return {\"Transition Duration\",\"Video Duration\"}\r\n",
     "kind": "func",
     "name": "limitVideoBlendDurationMode",
     "path": "ISAACPlayer24H.Helper.limitVideoBlendDurationMode"
    },
    {
     "body": "local hour = os.date(\"%H\");\r\nlocal minute = os.date(\"%M\");\r\nlocal second = os.date(\"%S\");\r\n\r\nlocal s =((tonumber(hour)*60) + tonumber(minute))*60+tonumber(second)\r\n--pixc.log(s)\r\nreturn s\r\n",
     "kind": "func",
     "name": "secondsToday",
     "path": "ISAACPlayer24H.Helper.secondsToday"
    },
    {
     "body": "if(data == nil or filename == nil) then\r\n\treturn\r\nend\r\nself.Helper.requireJson()\r\nlocal s = \"\"\r\nif(type(data) == \"table\") then\r\n\ts = self.jsonlib.encode(data)\r\nelse\r\n\ts = data..\"\";\r\nend\r\n\r\n\r\nlocal f = io.open(filename,\"w\")\r\nif(f ~= nil) then\r\n\tf:write(s)\r\n\tf:close()\r\n\tf = nil\r\nend\r\n",
     "kind": "func",
     "name": "dumpToFile",
     "params": [
      {
       "name": "data",
       "type": ""
      },
      {
       "name": "filename",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Helper.dumpToFile"
    },
    {
     "body": "if(timeline == nil) then return end\r\nif(time == nil ) then return end\r\nif(name == nil) then return end\r\n\r\nlocal offset = 0;\r\nlocal ok = false;\r\nlocal cues = timeline.getCues()\r\nfor i = 1 , #cues do\r\n\tif cues[i].getName() == name then\r\n\t\tlocal ok = false\r\n\t\twhile ok == false do\r\n\t\t\tok = cues[i].setTime( time+offset);\r\n\t\t\tif(ok == true) then \r\n\t\t\t\tif( offset > 0) then\r\n\t\t\t\t\tself.log(1,\"update Cue\"..name..\" Offset (move)\",offset)\r\n\t\t\t\tend\r\n\t\t\t\treturn cues[i],false\r\n\t\t\tend\r\n\t\t\toffset = offset +1\r\n\t\tend\r\n\tend\r\nend\r\noffset = 0\r\nlocal cue = nil\r\nwhile cue == nil do\r\n\tlocal cue = timeline.createCue(name, time+offset, 0)\r\n\tif cue ~= nil then\r\n\t\tif( offset > 0) then\r\n\t\t\tself.log(1,\"update Cue \"..name..\" Offset (create)\",offset)\r\n\t\tend\r\n\t\treturn cue,true\r\n\tend\r\n\toffset = offset +1\r\nend\r\n",
     "kind": "func",
     "name": "moveCue",
     "params": [
      {
       "name": "timeline",
       "type": ""
      },
      {
       "name": "name",
       "type": ""
      },
      {
       "name": "time",
       "type": ""
      },
      {
       "name": "doCreate",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Helper.moveCue"
    },
    {
     "body": "if self.reinitOnSystemTimeChange == true then\r\n\tself.Errorhelper.addError(\"System Time Changed -> Reinit \",\"info\")\r\n\tself.init()\r\nelse\r\n\tself.Errorhelper.addError(\"System Time Changed -> reinit disabled\",\"info\")\r\nend\r\n",
     "kind": "func",
     "name": "systemTimeChanged",
     "path": "ISAACPlayer24H.Helper.systemTimeChanged"
    },
    {
     "body": "return {\"On Demand\",\"On Init\", \"Manual\"}\r\n",
     "kind": "func",
     "name": "getCompositionModes",
     "path": "ISAACPlayer24H.Helper.getCompositionModes"
    },
    {
     "body": "--self.timelineUpdatePauseSupported = false\r\nif self.timelineUpdatePauseSupported == false then\r\n\treturn\r\nend\r\n\r\nlocal ok,err = pcall(Pixera.Compound.blockUiTimelineUpdates,true)\r\nif ok == false then\r\n\tself.timelineUpdatePauseSupported = false\r\n\tself.log(1,\"Pausing timelineupdates not supported in this Pixera version, continue without pauseing\")\r\nelse\r\n\t--pixc.log(\"PAUSE\")\r\nend\r\n",
     "kind": "func",
     "name": "pauseTimelineUpdates",
     "path": "ISAACPlayer24H.Helper.pauseTimelineUpdates"
    },
    {
     "body": "if self.timelineUpdatePauseSupported == false then\r\n\treturn\r\nend\r\n\r\nlocal ok,err = pcall(Pixera.Compound.blockUiTimelineUpdates,false)\r\nif ok == false then\r\n\tself.timelineUpdatePauseSupported = false\r\n\tself.log(1,\"Pausing timelineupdates not supported in this Pixera version, continue without pauseing\")\r\n\r\nelse\r\n\t\r\n\t--pixc.log(\"CONTINUE\")\r\nend\r\n",
     "kind": "func",
     "name": "continueTimelineUpdates",
     "path": "ISAACPlayer24H.Helper.continueTimelineUpdates"
    },
    {
     "body": "\r\nif self.Helper.getOffsetFromTodaysMidnightMs == nil then\r\n\tself.Helper.getOffsetFromTodaysMidnightMs = function(time)\r\n\t\tlocal midnight = os.date(\"%Y-%m-%d 00:00:00%z\")\r\n\t\t--pixc.log(midnight)\r\n\t\t--local currentTime = pixc.getRoot().Utils.Timer.now();\r\n\t\t--local currentTimeUtc = pixc.getRoot().Utils.Timer.toStringUtc(currentTime);\r\n\r\n\t\treturn pixc.getRoot().Utils.Timer.timeStringDiff( time,midnight,\"ms\")\r\n\tend\r\n\t--pixc.log(\"getOffsetFromTodaysMidnightMs registered\")\r\n end\r\n",
     "kind": "func",
     "name": "registerHelperFunctions",
     "path": "ISAACPlayer24H.Helper.registerHelperFunctions"
    }
   ],
   "kind": "ns",
   "name": "Helper"
  },
  {
   "kind": "ns",
   "name": "Variables"
  },
  {
   "elems": [
    {
     "body": "--\nif self.protocol == nil then self.log(1,\"not initialized\") return end\n--\nif self.jsonlib == nil then\n\tself.jsonlib = require \"json\" \nend\nlocal parameter = {}\nparameter[\"beforeCount\"] = \"0\"\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\nlocal url = self.url..\"/api/v1/schedule/calendars/1/scheduledItems\"\n--self.log(1,url)\nlocal success, code, headerDict, content = self.protocol:httpGet(url,parameter)\nif(success) then\n\t--self.log(1,code)\n\t--self.log(1,content)\n\tif code == 200 then\n\t\tself.calendar1 = self.jsonlib.decode(content)\n\t\tlocal toRm = {}\n\t\tfor k , v  in ipairs(self.calendar1) do\n\t\t\tif v.itemType ~= \"EVENT\" then\n\t\t\t\ttable.insert(toRm,k)\n\t\t\telse\n\t\t\t\tif self.eventKeys[v.itemId] == true then\n\t\t\t\t\tself.log(1,\"Ok\", v.displayName,v._id)\n\t\t\t\telse\n\t\t\t\t\ttable.insert(toRm,k)\n\t\t\t\t\t--self.log(1,\"Wrong\", v.displayName,v._id)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tfor i = #toRm, 1, -1  do\n\t\t\t--self.log(1,\"rm\",toRm[i], self.calendar1[toRm[i]] ~= nil)\n\t\t\ttable.remove(self.calendar1, toRm[i])\n\t\tend\n\telse\n\t\tself.log(1,\"getCalendarScheduledItems failed with code\", code)\n\tend\nend\nself.Schedule.updateSchedulerEntries();\nself.schdedulerTriggerActive = false\nself.Helper.triggerGetCalendarEntries()\n",
     "kind": "func",
     "name": "getCalendarScheduledItems",
     "path": "ISAACPlayer24H.Schedule.getCalendarScheduledItems"
    },
    {
     "body": "--\r\nif self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nif self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\nlocal obj = {}\r\nobj.description = \"Description of \".. name\r\nobj.lastValue = value\r\nobj.displayName = name\r\nobj.externalRef = self()..name\r\n--obj.subsystemId = 15\r\nobj.subsystemExternalId = self.externalId\r\n\r\nstr = self.jsonlib.encode(obj);\r\nself.log(1,str);\r\n\r\n\r\n\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\nlocal parameter = nil\r\n\r\nlocal url = self.url..\"/api/v1/variables\"\r\n--local url = \"http://127.0.0.1:3000/api/v1/events\"\r\n--self.log(1,url)\r\nlocal success, code, headerDict, content = self.protocol:httpPost(url,str,parameter,customHeader)\r\nif(success) then\r\n\tself.log(1,code)\r\n\tself.log(1,content)\r\nend\r\n",
     "kind": "func",
     "name": "addVariable2",
     "params": [
      {
       "name": "name",
       "type": "string"
      },
      {
       "name": "value",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.Schedule.addVariable2"
    },
    {
     "body": "--\r\nif self.protocol == nil   then self.log(1,\"not initialized\") return end\r\nif name == nil then  return end\r\n--\r\nif self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\nlocal obj = {}\r\nobj.description = \"Description of \".. name\r\nobj.lastValue = value\r\nobj.displayName = name\r\nobj.externalRef = self()..name\r\n--obj.subsystemId = 15\r\nobj.subsystemExternalId = self.externalId\r\n\r\nstr = self.jsonlib.encode(obj);\r\nself.log(1,str);\r\n\r\n\r\n\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\nlocal parameter = nil\r\n\r\nlocal url = self.url..\"/api/v1/variables\"\r\n--local url = \"http://127.0.0.1:3000/api/v1/events\"\r\n--self.log(1,url)\r\nlocal success, code, headerDict, content = self.protocol:httpPost(url,str,parameter,customHeader)\r\nif(success) then\r\n\tself.log(1,code)\r\n\tself.log(1,content)\r\nend\r\n",
     "kind": "func",
     "name": "addVariable",
     "params": [
      {
       "name": "name",
       "type": "string"
      },
      {
       "name": "value",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.Schedule.addVariable"
    },
    {
     "body": "local schedule = Utils.Scheduler.getSchedule(self.scheduleName)\nif schedule == nil or schedule.getHandleInt() == 0 then\n\t--Schedule does not exist create it.\n\tschedule = Utils.Scheduler.createSchedule(self.scheduleName, self()..'')\nend\nself.schedule = schedule\n",
     "kind": "func",
     "name": "getSchedule",
     "path": "ISAACPlayer24H.Schedule.getSchedule"
    },
    {
     "body": "--\nlocal currentEntries = self.schedule.getAllEntries();\nlocal currentEntrieToDeleteMap = {}\nlocal currentEntrieNameToHdl = {}\nif self.jsonlib == nil then\n\tself.jsonlib = require \"json\" \nend\nfor k,v in ipairs(currentEntries) do\n\tlocal name = v.get(\"_id\")\n\tif(not self.Schedule.isReservedScheduleEntry(v.get(\"name\"))) then\n    \tcurrentEntrieToDeleteMap[name] = true\n\t\tcurrentEntrieNameToHdl[name] = v\n\tend\n\t\nend\nlocal json = {};\nfor k , v  in ipairs(self.calendar1) do\n\tjson = {}\n\tjson[\"name\"] = v.displayName\n\tjson[\"_id\"] = v._id\n\tjson[\"start\"] = v.startTime\n\tjson[\"end\"] = v.endTime\n\tlocal action = {}\n\taction[v.itemId..\"\"] = \"\"\n\tjson[\"actions\"] = action\n\tlocal jsonStr = self.jsonlib.encode(json);\n\tif currentEntrieToDeleteMap[v._id] == nil then\n-- add\nself.log(1,self()..\" Adding\",v.displayName,v._id)\n\t\tself.schedule.createEntry(jsonStr)\n\t\tcurrentEntrieToDeleteMap[v._id] = false\n\telse\n-- update\nself.log(1,self()..\" updateing\",v.displayName,v._id)\n\t\tcurrentEntrieNameToHdl[v._id].update(jsonStr)\n\t\tcurrentEntrieToDeleteMap[v._id] = false\n\tend\nend\nfor k,v in pairs(currentEntrieToDeleteMap) do\n\tif v == true then\n\t\t--self.log(1,self()..\" removing\",k)\t\n\t\tcurrentEntrieNameToHdl[k].remove()\n\tend\nend\n",
     "kind": "func",
     "name": "updateSchedulerEntries",
     "path": "ISAACPlayer24H.Schedule.updateSchedulerEntries"
    },
    {
     "body": "return self.reservedScheduleEvent[name] ~= nil;\r\n",
     "kind": "func",
     "name": "isReservedScheduleEntry",
     "params": [
      {
       "name": "name",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.Schedule.isReservedScheduleEntry"
    }
   ],
   "kind": "ns",
   "name": "Schedule"
  },
  {
   "elems": [
    {
     "body": "if self.useTimecode == true then\r\n\tself.TimelineMain().setSmpteMode(0)\r\nend\r\nself.forceStop = true\r\nself.TimelineMain().pause();\r\nif self.enableInstantPlay == true then\r\n\tlocal tl = self.TimelineInstant()\r\n\tself.instantPlayStatus = \"Stop\";\r\n\ttl.stop()\r\n\tself.Player.cleanTimeline(tl);\r\n\r\n\t--self.Player.run24Timeline(self.instantPlayFadeTimeS,true)\r\n\tself.instantPlayStatusLoop = \"\";\r\n\tself.instantPlayMedia = \"\";\r\n\tself.instantIsCustom = nil\r\n\tself.instantPlayableInfo  = nil\r\nend\r\n",
     "kind": "func",
     "name": "pause",
     "path": "ISAACPlayer24H.Player.pause"
    },
    {
     "body": "if self.useTimecode == true then\r\n\tself.TimelineMain().setSmpteMode(0)\r\nend\r\nself.forceStop = true\r\nself.TimelineMain().stop();\r\n\r\nif self.enableInstantPlay == true then\r\n\tlocal tl = self.TimelineInstant()\r\n\tself.instantPlayStatus = \"Stop\";\r\n\ttl.stop()\r\n\tself.Player.cleanTimeline(tl);\r\n\tself.instantPlayStatusLoop = \"\";\r\n\tself.instantPlayMedia = \"\";\r\n\tself.instantIsCustom = nil\r\n\tself.instantPlayableInfo  = nil\r\nend\r\n\r\n",
     "kind": "func",
     "name": "stop",
     "path": "ISAACPlayer24H.Player.stop"
    },
    {
     "body": "if self.useTimecode == true then\r\n\tself.TimelineMain().setSmpteMode(1)\r\nend\r\nself.forceStop = false\r\nself.Player.run24Timeline()\r\n",
     "kind": "func",
     "name": "play",
     "path": "ISAACPlayer24H.Player.play"
    },
    {
     "body": "--\r\nif self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nif self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\nlocal parameter = {}\r\n--parameter[\"subsystemExternalId\"] = self.externalId\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\n--local parameter = nil\r\nlocal url = self.url..\"/api/v1/players/\"..self.externalIdSchedule..\"/defaultState\"\r\n--self.log(1,url,self.externalId)\r\nlocal success, code, headerDict, content = self.protocol:httpGet(url,parameter)\r\nif(success) then\r\n\t--self.log(1,code)\r\n\t--self.log(1,content)\r\n\tif( code == 200) then\r\n\r\n\t\tself.playerDefaultState = self.jsonlib.decode(content)\r\n\t\t--self.log(1,\"playermode:\",self.jsonlib.encode(self.playerDefaultState.mediaDetails))\r\n\t\tlocal objectsToPlay = self.playerDefaultState.mediaDetails.objects;\r\n\t\t--self.log(1,\"objects:\",self.jsonlib.encode(objectsToPlay))\r\n\t\tself.ContentHandling.runSyncTool(objectsToPlay)\r\n\t\tself.TimelineHandling.playLoop(self.playerDefaultState.mediaDetails.displayName)\r\n\telse\r\n\t\tself.Errorhelper.addError(\"GetPlayers defaultState failed \"..self.codeToString(code),\"error\")\r\n\tend\r\nend\r\n",
     "kind": "func",
     "name": "getPlayerState",
     "path": "ISAACPlayer24H.Player.getPlayerState"
    },
    {
     "body": "local command = {}\r\ncommand[1] = self()..\"Player.play\"\r\n\r\nself.Events.addEvent(\"Play\",\"defaultPlay\", command)\r\n",
     "kind": "func",
     "name": "addDefaultEvents",
     "path": "ISAACPlayer24H.Player.addDefaultEvents"
    },
    {
     "body": "--\r\nif self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nif self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\nlocal parameter = {}\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\nlocal url = self.url..\"/api/v1/players/\"..self.externalIdSchedule\r\nlocal success, code, headerDict, content = self.protocol:httpGet(url,parameter)\r\nif(success) then\r\n\tif( code == 200) then\r\n\t\tself.Player.logPlayState()\r\n\t\t--pixc.log(\"Playerinfo\",content)\r\n\t\tself.playerInfo = self.jsonlib.decode(content)\r\n\t\tif(self.playerInfo == nil) then\r\n\t\t\tself.Errorhelper.addError(\"getPlayersInfo decode Json failed\",\"error\")\r\n\t\tend\r\n\t\tself.playerName = self.playerInfo.displayName\r\n\t\tself.playerDefaultState = self.playerInfo.defaultState\r\n\t\tlocal playMode = self.playerInfo.playMode;\r\n\t\tif (self.playingstatus.mode ~= playMode) then\r\n\t\t\tself.playingstatus.state = \"none\"\r\n\t\t\tself.playingstatus.downloadState = \"invalid\"\r\n\t\t\tself.Errorhelper.addError(\"Playmode \"..playMode..\" active\",\"info\")\r\n\t\tend\r\n\t\tif(self.stopTlInstantPlay == true) then\r\n\t\t\tif self.instantPlayStatus == \"Play\" then\r\n\t\t\t\t--pixc.log(\"skipped becauseof instanPlay\")\r\n\t\t\t\tself.Player.registerTrigger()\r\n\t\t\t\treturn\r\n\t\t\tend\r\n\t\tend\r\n\t\tself.playingstatus.mode = playMode\r\n\t\tself.Player.logPlayState()\r\n\t\tself.Player.run24Timeline()\r\n\t\tif(self.playingstatus.mode == \"loop\") then\r\n\t\t\tself.Player.handleLoopBeginStates()\r\n\t\t\tself.Player.handleLoopFromDownloadState()\r\n\t\tend\r\n\t\tif(\tself.playingstatus.mode == \"schedule\") then\r\n\t\t\tself.Player.handleScheduleBeginStates()\r\n\t\tend\r\n\t\tif(\tself.playingstatus.mode == \"none\") then\r\n\r\n\t\tend\r\n\r\n--\t\tself.log(1,\"playermode:\",self.jsonlib.encode(self.playerDefaultState.mediaDetails))\r\n--\t\tlocal objectsToPlay = self.playerDefaultState.mediaDetails.objects;\r\n--\t\tself.log(1,\"objects:\",self.jsonlib.encode(objectsToPlay))\r\n--\t\tself.ContentHandling.runSyncTool(objectsToPlay)\r\n--\t\tself.TimelineHandling.playLoop(self.playerDefaultState.mediaDetails.displayName)\r\n\telse\r\n\t\tself.Errorhelper.addError(\"getPlayerInfo failed with code \"..self.codeToString(code),\"error\")\r\n\tend\r\nend\r\n",
     "kind": "func",
     "name": "getPlayerInfo",
     "path": "ISAACPlayer24H.Player.getPlayerInfo"
    },
    {
     "body": "if(self.events == nil) then\r\n\tself.Events.getEvents();\r\n\tif(self.events == nil) then\r\n\t\tself.log(1,self()..\" sync Default Event: Events object is nil, even after getEvents\");\r\n\t\treturn\r\n\tend\r\nend\r\nlocal ev = {[\"Play\"] = {\"Player.play\",{}},[\"Pause\"] = {\"Player.pause\",{}},[\"Stop\"] = {\"Player.stop\",{}}}\r\n\tif self.jsonlib == nil then\r\n\t\tself.jsonlib = require \"json\" \r\n\tend\r\n--self.log(1,self.jsonlib.encode(self.events));\r\nfor name,f in pairs(ev) do\r\n\t--self.log(1,name,f)\r\n\tlocal command = {}\r\n\tcommand[1] = self()..\".\"..f[1]\r\n\tcommand[2] = f[2]\r\n\r\n\tlocal commandencoded = self.jsonlib.encode(command);\r\n\r\n    local found = false\r\n\tlocal n = self.playerName..\" \"..name \r\n\tlocal d = \"default \"..self.playerName..\" \"..name\r\n\tfor _1, evServer in ipairs(self.events) do\r\n\t\tif evServer.displayName == n and evServer.description == d then\r\n\t\t\tfound = true;\r\n\t\t\t--self.log(1,\"command\",evServer.command,commandencoded)\r\n\t\t\tif( evServer.command ~= commandencoded) then\r\n\t\t\t\t--self.log(1,\"commandupdateReqired\",evServer.displayName)\r\n\t\t\t\tself.Events.updateEvent(evServer._id,evServer.displayName,evServer.description,command)\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\tif found == false then\r\n\t\tself.Events.addEvent(n,d, command)\r\n\t\t--self.log(1,self()..\" add defautl\", n,d)\r\n\tend\r\n\tfound = false\r\nend\r\nself.Events.getEvents()\r\n",
     "kind": "func",
     "name": "syncDefaultEvents",
     "path": "ISAACPlayer24H.Player.syncDefaultEvents"
    },
    {
     "body": "if(self.playingstatus.mode ~= \"loop\") then\r\n\treturn\r\nend\r\nlocal mediaArray = {}\r\nif( self.playingstatus.state ~= \"none\") then\r\n\tif self.playerDefaultState.mediaDetails ~= nil and self.playerDefaultState.mediaDetails.objects ~= nil then\r\n\t\tlocal type, name,command = self.Player.parseCommand(self.playerDefaultState.mediaDetails.command)\r\n\t\tself.log(1,\"loop\",type,name)\r\n\t\tlocal playableChanged = false\r\n\t\tif self.playingstatus.loopFile.typ ~= type then\r\n\t\t\tself.playingstatus.state = \"none\"\r\n\t\t\tself.playingstatus.loopComposition = {}\r\n\t\t\tplayableChanged = true\r\n\t\tend\r\n\r\n\t\t\r\n\t\tif( type == \"composition\") then\r\n\t\t\tif( command ~= nil and command.data ~= nil) then\r\n\t\t\t\tif #command.data ~= #self.playingstatus.loopComposition then\r\n\t\t\t\t\tfor k,v in pairs(command.data) do\r\n\t\t\t\t\t\tif(type(v) == 'table' and v.objectName ~= nil) then\r\n\t\t\t\t\t\t\tif( self.playingstatus.loopComposition[k].objectName ~= v.objectName) then\r\n\t\t\t\t\t\t\t\tself.playingstatus.state = \"none\"\r\n\t\t\t\t\t\t\t\tself.playingstatus.loopComposition = {}\r\n\t\t\t\t\t\t\t\tplayableChanged = true\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tif( self.playingstatus.loopComposition[k] ~= v) then\r\n\t\t\t\t\t\t\t\tself.playingstatus.state = \"none\"\r\n\t\t\t\t\t\t\t\tself.playingstatus.loopComposition = {}\r\n\t\t\t\t\t\t\t\tplayableChanged = true\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\tend\r\n\t\t\t\telse\r\n\t\t\t\t\tself.playingstatus.state = \"none\"\r\n\t\t\t\t\tself.playingstatus.loopComposition = {}\r\n\t\t\t\t\tplayableChanged = true\r\n\t\t\t\tend\t\t\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tif self.playingstatus.loopFile._id \t~= self.playerDefaultState.mediaDetails.objectsDetails[1]._id then \r\n\t\t\t\tself.playingstatus.state = \"none\"\r\n\t\t\t\tself.playingstatus.loopComposition = {}\r\n\t\t\t\tplayableChanged = true\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tif playableChanged == true then\r\n\t\t\tself.playingstatus.state = \"none\"\r\n\t\t\tself.playingstatus.loopComposition = {}\r\n\t\t\t--self.Player.stopCurrentPlayback();\r\n\t\telse\r\n\t\t\t-- video not changed but update instant play\r\n\t\t\tlocal video = {}\r\n\t\t\tif self.enableInstantPlay == true then \t\t\t\t\r\n\t\t\t\tlocal vid = self.Player.getInstantPlayables();\r\n\t\t\t\tfor k,v in ipairs(vid) do\r\n\t\t\t\t\ttable.insert(video,v);\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\tfor k,v in ipairs(self.playingstatus.loopFile.videoSyncArray) do\r\n\t\t\t\ttable.insert(video,v);\r\n\t\t\tend\r\n\r\n\t\t\tif(self.useNasSmb == true) then\t\t\r\n\t\t\t\tif(self.removeAssetsMode == \"Dayli\") then\r\n\t\t\t\t\tlocal required = self.ContentHandling.isDayliCleanRequired()\t\r\n\t\t\t\t\tif required == true then\t\r\n\t\t\t\t\t\tself.ContentHandling.syncToResourceFolder(nil,video,nil,nil,nil,\"CLEAN_FORCE\");\r\n\t\t\t\t\t\tself.ContentHandling.dayliCleanDone() \r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tself.ContentHandling.syncToResourceFolder(nil,video,nil,nil,nil,\"CLEAN_NO\");\r\n\t\t\t\t\tend\r\n\t\t\t\telse\r\n\t\t\t\t\tself.ContentHandling.syncToResourceFolderCleanAware(nil,video,nil,nil,nil);\r\n\t\t\t\tend\r\n\t\t\t\tself.Hooks.postMediaSync(self.externalIdSchedule,true); \r\n\t\t\telse\r\n\t\t\t\tlocal overrideCleanForDownloader = nil\r\n\t\t\t\tif(self.removeAssetsMode == \"Dayli\") then\r\n\t\t\t\t\toverrideCleanForDownloader = self.ContentHandling.isDayliCleanRequired()\t\r\n\t\t\t\telse\r\n\t\t\t\t\tif(self.removeAssetsMode == \"Never\") then\r\n\t\t\t\t\t\toverrideCleanForDownloader = false\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\toverrideCleanForDownloader = true\r\n\t\t\t\t\tend\r\n\t\t\t\tend\t\r\n\t\t\t\tself.ContentHandling.runSyncTool(self.playingstatus.loopFile._id, \r\n\t\t\t\t\tfunction() \r\n\t\t\t\t\tif(self.removeAssetsMode == \"Dayli\") then\r\n\t\t\t\t\t\tlocal required = self.ContentHandling.isDayliCleanRequired()\t\r\n\t\t\t\t\t\tif required == true then\t\r\n\t\t\t\t\t\t\tself.ContentHandling.syncToResourceFolder(nil,nil,nil,nil,nil,\"CLEAN_FORCE\");\r\n\t\t\t\t\t\t\tself.ContentHandling.dayliCleanDone() \r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tself.ContentHandling.syncToResourceFolder(nil,nil,nil,nil,nil,\"CLEAN_NO\");\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\telse \r\n\t\t\t\t\t\tself.ContentHandling.syncToResourceFolderCleanAware(nil,nil,nil,nil,nil);\r\n\t\t\t\t\tend\r\n\t\t\t\t\tself.Hooks.postMediaSync(self.externalIdSchedule,true);\r\n\t\t\t\t\tend\r\n\t\t\t\t ,overrideCleanForDownloader)\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\n--self.Player.logPlayState()\r\n\r\nif( self.playingstatus.state == \"none\") then\r\n\t--start\r\n\tself.playingstatus.loopFile = {};\r\n\tif self.playerDefaultState.mediaDetails ~= nil and self.playerDefaultState.mediaDetails.objects ~= nil then\r\n\t\tlocal typ, objectName, command = self.Player.parseCommand(self.playerDefaultState.mediaDetails.command)\t\r\n\t\tpixc.log(\"Type \",typ)\r\n\t\tif typ == \"composition\" then \r\n\t\t\tself.playingstatus.loopFile = self.playerDefaultState.mediaDetails\r\n\t\t\tself.playingstatus.loopFile.typ = typ;\r\n\t\t\tself.playingstatus.loopFile.videoSyncArray = {}\r\n\t\t\tself.playingstatus.loopComposition = {}\r\n\t\t\tmediaArray = self.playerDefaultState.mediaDetails.objects\r\n\t\t\tif( command ~= nil and command.data ~= nil) then\r\n\t\t\t\tfor k,v in pairs(command.data) do\r\n\t\t\t\t\tif(type(v) == 'table' and v.objectName ~= nil) then\r\n\t\t\t\t\t\tself.playingstatus.loopComposition[k] = v\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tself.playingstatus.loopComposition[k]  = v\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\tfor k,v in ipairs(self.playerDefaultState.mediaDetails.objectsDetails) do\r\n\t\t\t\ttable.insert(self.playingstatus.loopFile.videoSyncArray, objectName);\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tself.playingstatus.loopFile = self.playerDefaultState.mediaDetails.objectsDetails[1]\r\n\t\t\tself.playingstatus.loopFile.typ = typ;\r\n\t\t\tself.playingstatus.loopFile.videoSyncArray = {}\r\n\t\t\ttable.insert(self.playingstatus.loopFile.videoSyncArray, object);\r\n\t\tend\t\r\n\t\tif typ == \"custom\" then\r\n\t\t\tself.playingstatus.state = \"playing\"\r\n\t\t\tself.TimelineHandling.playLoopCustom(command,self.playerDefaultState.mediaDetails.duration)\r\n\t\t\tself.Player.registerTrigger();\r\n\t\t\treturn\r\n\t\telse\r\n\t\t\tself.playingstatus.state = \"startDownloading\"\t\r\n\t\tend\r\n\tend\r\nend\r\nif(self.playingstatus.state == \"startDownloading\") then\r\n\tif(  self.ContentHandling.checkRunning() == false) then\r\n\t\tself.playingstatus.state = \"downloading\"\r\n\t\tlocal video = {}\r\n\t\tif self.enableInstantPlay == true then \t\t\t\t\r\n\t\t\tlocal vid = self.Player.getInstantPlayables();\r\n\t\t\tfor k,v in ipairs(vid) do\r\n\t\t\t\ttable.insert(video,v);\r\n\t\t\tend\r\n\t\tend\r\n\t\tfor k,v in ipairs(self.playingstatus.loopFile.videoSyncArray) do\r\n\t\t\ttable.insert(video,v);\r\n\t\tend\r\n\t\tif(self.useNasSmb == true) then\t\r\n\t\t\tif(self.removeAssetsMode == \"Dayli\") then\r\n\t\t\t\tlocal required = self.ContentHandling.isDayliCleanRequired()\t\r\n\t\t\t\tif required == true then\t\r\n\t\t\t\t\tself.ContentHandling.syncToResourceFolder(nil,video,nil,nil,nil,\"CLEAN_FORCE\");\r\n\t\t\t\t\tself.ContentHandling.dayliCleanDone() \r\n\t\t\t\telse\r\n\t\t\t\t\tself.ContentHandling.syncToResourceFolder(nil,video,nil,nil,nil,\"CLEAN_NO\");\r\n\t\t\t\tend\r\n\t\t\telse\r\n\t\t\t\tself.ContentHandling.syncToResourceFolderCleanAware(nil,video,nil,nil,nil);\r\n\t\t\tend\t\r\n\t\t\tself.ContentHandling.isTransferFinished(true);\r\n\t\t\tself.playingstatus.downloadState = \"valid\"; \r\n\t\t\tself.Hooks.postMediaSync(self.externalIdSchedule,true);\r\n\t\t\tself.Player.handleScheduleContinueStates();\r\n\t\telse\r\n\t\t\tlocal overrideCleanForDownloader = nil\r\n\t\t\tif(self.removeAssetsMode == \"Dayli\") then\r\n\t\t\t\toverrideCleanForDownloader = self.ContentHandling.isDayliCleanRequired()\t\r\n\t\t\telse\r\n\t\t\t\tif(self.removeAssetsMode == \"Never\") then\r\n\t\t\t\t\toverrideCleanForDownloader = false\r\n\t\t\t\telse\r\n\t\t\t\t\toverrideCleanForDownloader = true\r\n\t\t\t\tend\r\n\t\t\tend\t\r\n\t\t\tself.ContentHandling.runSyncTool(mediaArray, \r\n\t\t\tfunction() \r\n\t\t\tif(self.removeAssetsMode == \"Dayli\") then\r\n\t\t\t\tlocal required = self.ContentHandling.isDayliCleanRequired()\t\r\n\t\t\t\tif required == true then\t\r\n\t\t\t\t\tself.ContentHandling.syncToResourceFolder(nil,nil,nil,nil,nil,\"CLEAN_FORCE\");\r\n\t\t\t\t\tself.ContentHandling.dayliCleanDone() \r\n\t\t\t\telse\r\n\t\t\t\t\tself.ContentHandling.syncToResourceFolder(nil,nil,nil,nil,nil,\"CLEAN_NO\");\r\n\t\t\t\tend\r\n\t\t\telse \r\n\t\t\t\tself.ContentHandling.syncToResourceFolderCleanAware(nil,nil,nil,nil,nil);\r\n\t\t\tend\r\n\t\t\tself.Hooks.postMediaSync(self.externalIdSchedule,true);\r\n\t\t\tself.Player.handleLoopFromDownloadState() \r\n\t\t\tend,overrideCleanForDownloader)\r\n\t\tend\r\n\tend\r\nend\r\n",
     "kind": "func",
     "name": "handleLoopBeginStates",
     "path": "ISAACPlayer24H.Player.handleLoopBeginStates"
    },
    {
     "body": "if(self.playingstatus.mode ~= \"loop\") then\r\n\treturn\r\nend\r\n\r\nself.Player.logPlayState()\r\nif(self.playingstatus.state == \"downloading\") then\r\n\tself.playingstatus.state = \"checkHandle\"\r\nend\r\n\r\nif(self.playingstatus.state == \"checkHandle\") then\r\n\tif \tself.playingstatus.loopFile.typ == \"composition\" then\r\n\t\tfor k,v in pairs(self.playingstatus.loopComposition) do\r\n\t\t\tif(type(v) == 'table' and v.objectName ~= nil ) then\r\n\t\t\t\tlocal h = self.ContentHandling.getHandleFormMedia(\"video\",v.objectName);\r\n\t\t\t\tif h == nil then\r\n\t\t\t\t\tself.log(1,\"Missing handle to file \"..v.objectName)\r\n\t\t\t\t\tself.Player.registerTrigger();\r\n\t\t\t\t\treturn\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\telse\r\n\t\tlocal h = self.ContentHandling.getHandleFormMedia(\"video\",self.playingstatus.loopFile.object);\r\n\t\tif h ~= nil then\r\n\t\t\tself.playingstatus.state = \"waitPendingTransfers\"\r\n\t\telse\r\n\t\t\tself.log(1,\"Missing handle to file \"..self.playingstatus.loopFile.object)\r\n\t\t\tself.Player.registerTrigger();\r\n\t\t\treturn\r\n\t\tend\r\n\tend\r\n\tself.playingstatus.state = \"waitPendingTransfers\"\r\nend\r\n\r\nif(self.playingstatus.state == \"waitPendingTransfers\") then\r\n\tif \tself.playingstatus.loopFile.typ == \"composition\" then\r\n\t\tlocal allOk = true\r\n\t\tfor k,v in pairs(self.playingstatus.loopComposition) do\r\n\t\t\tif(type(v) == 'table' and v.objectName ~= nil ) then\r\n\t\t\t\tlocal h = self.ContentHandling.getHandleFormMedia(\"video\",v.objectName);\r\n\t\t\t\tif h == nil then\r\n\t\t\t\t\tif h ~= nil then\r\n\t\t\t\t\t\tself.log(1,\"pendingTransfers\",h,h.getName(),h.getHasPendingTransfer(),\" check \",self.checkPendingTransfers)\r\n\t\t\t\t\t\tif self.checkPendingTransfers == false or (self.checkPendingTransfers == true and h.getHasPendingTransfer() == false) then\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t--pixc.log(\"Transfers ok \",h,h.getName())\t\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tself.log(1,\"Transfers are pending for \",h,h.getName())\r\n\t\t\t\t\t\t\tallOk = false\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tself.log(1,self()..\" missing handle to file \"..v.objectNamet)\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\t\tif allOk == true then\r\n\t\t\tself.playingstatus.state = \"startPlay\"\t\r\n\t\tend\r\n\telse\r\n\t\tlocal h = self.ContentHandling.getHandleFormMedia(\"video\",self.playingstatus.loopFile.object);\r\n\t\tif h ~= nil then\r\n\t\t\tself.log(1,\"pendingTransfers\",h,h.getName(),h.getHasPendingTransfer(),\" check \",self.checkPendingTransfers)\r\n\t\t\tif self.checkPendingTransfers == false or (self.checkPendingTransfers == true and h.getHasPendingTransfer() == false) then\r\n\t\t\t\tself.playingstatus.state = \"startPlay\"\t\t\r\n\t\t\t\t--pixc.log(\"Transfers ok \",h,h.getName())\t\r\n\t\t\telse\r\n\t\t\t\tself.log(1,\"Transfers are pending for \",h,h.getName())\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tself.log(1,self()..\" missing handle to file \"..self.playingstatus.loopFile.object)\r\n\t\tend\r\n\tend\r\n\t\r\nend\r\n\r\nif(self.playingstatus.state == \"startPlay\") then\r\n\tself.playingstatus.state = \"playing\"\r\n\tlocal dur = nil;\r\n\tif(self.playingstatus.loopFile.metadata ~= nil ) then\r\n\t\tdur = self.playingstatus.loopFile.metadata.duration;\r\n\tend\r\n\tif \tself.playingstatus.loopFile.typ == \"composition\" then\t\t\r\n\t\tself.TimelineHandling.playLoopComposition(self.playingstatus,self.playingstatus.loopFile.duration)\t\r\n\telse\r\n\t\tself.TimelineHandling.playLoop(self.playingstatus.loopFile.object,dur)\t\r\n\tend\r\nend\r\n\r\nif(self.playingstatus.state == \"play\") then\r\n\r\nend\r\nself.Player.registerTrigger();\r\n",
     "kind": "func",
     "name": "handleLoopFromDownloadState",
     "path": "ISAACPlayer24H.Player.handleLoopFromDownloadState"
    },
    {
     "body": "if(self.playingstatus.mode ~= \"schedule\") then\r\n\treturn\r\nelse\r\n\t-- pull schedule before ObjectList for later, otherwise object can be miss if added while downloading\r\n\tself.playingstatus.downloadState = \"invaild\"\r\n\tself.pulledSchedule,self.vNext = self.Player.getPlayerSchedule(); \r\n\t\r\n\tself.playingstatus.scheduleObjectList = self.Player.getPlayerScheduleObjectList(self.elementsToPull)\r\n\tlocal video,image,audio,other = self.Player.getObjectsListAsArray(nil,self.playingstatus.scheduleObjectList)\r\n\tif self.enableInstantPlay == true then \r\n\t\tlocal vid = self.Player.getInstantPlayables();\r\n\t\tfor k,v in ipairs(vid) do\r\n\t\t\t--pixc.log(\"instant\",v)\r\n\t\t\ttable.insert(video,v);\r\n\t\tend\r\n\tend\r\n    if(self.useNasSmb == true) then\r\n \t\tself.ContentHandling.syncToResourceFolderCleanAware(nil,video,image,audio,other); \r\n\r\n        self.ContentHandling.isTransferFinished(true);\r\n        self.playingstatus.downloadState = \"valid\"; \r\n        self.Hooks.postMediaSync(self.externalIdSchedule,false);\r\n        self.Player.handleScheduleContinueStates();\r\n\t\tif self.removeAssetsMode == \"Dayli\" then\t\r\n\t\t\tlocal required = self.ContentHandling.isDayliCleanRequired()\r\n\t\t\tif(required) then\r\n\t\t\t\tlocal video,image,audio,other = self.Player.getObjectsListAsArray(nil,self.Player.getPlayerScheduleObjectList(self.elementsToPull))\r\n\t\t\t\tif self.enableInstantPlay == true then \r\n\t\t\t\t\tlocal vid = self.Player.getInstantPlayables();\r\n\t\t\t\t\tfor k,v in ipairs(vid) do\r\n\t\t\t\t\t\ttable.insert(video,v);\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\tself.ContentHandling.syncToResourceFolder(nil,video,image,audio,other,\"CLEAN_FORCE\");\r\n\t\t\t\tself.ContentHandling.dayliCleanDone()\r\n\t\t\tend\r\n\t\tend\r\n    else\r\n\t\tlocal overrideCleanForDownloader = nil\r\n\t\tif(self.removeAssetsMode == \"Dayli\") then\r\n\t\t\toverrideCleanForDownloader = self.ContentHandling.isDayliCleanRequired()\t\r\n\t\telse\r\n\t\t\tif(self.removeAssetsMode == \"Never\") then\r\n\t\t\t\toverrideCleanForDownloader = false\r\n\t\t\telse\r\n\t\t\t\toverrideCleanForDownloader = true\r\n\t\t\tend\r\n\t\tend\t\r\n\t    self.ContentHandling.runSyncToolSchedule(\r\n\t\t\tfunction()\r\n\t\t\t\tif(self.removeAssetsMode == \"Dayli\") then\r\n\t\t\t\t\tlocal required = self.ContentHandling.isDayliCleanRequired()\t\r\n\t\t\t\t\tif required == true then\t\r\n\t\t\t\t\t\tself.ContentHandling.syncToResourceFolder(nil,nil,nil,nil,nil,\"CLEAN_FORCE\");\r\n\t\t\t\t\t\tself.ContentHandling.dayliCleanDone() \r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tself.ContentHandling.syncToResourceFolder(nil,nil,nil,nil,nil,\"CLEAN_NO\");\r\n\t\t\t\t\tend\r\n\t\t\t\telse \r\n\t\t\t\t\tself.ContentHandling.syncToResourceFolderCleanAware(nil,nil,nil,nil,nil);\r\n\t\t\t\tend\r\n\t\t\t\tself.ContentHandling.isTransferFinished(true);\r\n\t\t\t\tself.playingstatus.downloadState = \"valid\"; \r\n\t\t\t\tself.Hooks.postMediaSync(self.externalIdSchedule,false);\r\n\t\t\t\tself.Player.handleScheduleContinueStates();\r\n\t\t\t\tend\r\n\t\t\t,overrideCleanForDownloader)\r\n    end\r\nend\r\n",
     "kind": "func",
     "name": "handleScheduleBeginStates",
     "path": "ISAACPlayer24H.Player.handleScheduleBeginStates"
    },
    {
     "body": "if(self.playingstatus.mode ~= \"schedule\") then\r\n\treturn\r\nend\r\nlocal scheduleData = self.pulledSchedule\r\nlocal vNext = self.vNext\r\n-- schedule is now pulled before objectlist and downloader to prevent a possible race\r\n--local scheduleData,vNext = self.Player.getPlayerSchedule();\r\n\r\n if(scheduleData == nil) then\r\n\tself.log(1,\"getPlayerScheduleFailed\")\r\n\tself.Player.registerTrigger();\r\n\treturn\r\nend\r\n\r\nif( self.playingstatus.state ~= \"none\") then\r\n\r\nend\r\n--self.Player.logPlayState()\r\nif( self.playingstatus.state == \"none\") then\r\n\r\n\tif self.playingstatus.scheduleData == nil then\r\n\t\tself.playingstatus.scheduleData = scheduleData;\r\n\t\tself.playingstatus.scheduleData.vNext = vNext;\r\n\t\tself.Helper.pauseTimelineUpdates()\r\n\t\tself.Player.buildTimeline24(\"new\")\t\r\n\t\tself.Helper.continueTimelineUpdates()\r\n\t\tself.Player.registerTrigger();\t\r\n\t\treturn;\r\n\tend\r\n\tif self.playingstatus.scheduleData[1].generatedAt ~= scheduleData[1].generatedAt then\r\n\t\tself.log(1,\"Schedule changed generateAt comparison\",self.playingstatus.scheduleData[1].generatedAt, scheduleData[1].generatedAt)\r\n\t\tself.playingstatus.scheduleData = scheduleData;\r\n\t\tself.playingstatus.scheduleData.vNext = vNext;\r\n\t\tself.playingstatus.scheduleDataBefore = self.Player.getPlayerScheduleLastObject();\r\n\r\n\t\tif( self.playingstatus.scheduleData[1].generatedAt ~= self.playingstatus.scheduleDataBefore[1].generatedAt ) then\r\n\t\t\tself.log(1,\"Generate at mismatch repull schedule\")\r\n\t\t\tself.playingstatus.schedule = self.Player.getPlayerSchedule();\r\n\t\t\tself.playingstatus.scheduleDataBefore = self.Player.getPlayerScheduleLastObject();\r\n\t\tend\r\n\t\tself.Helper.pauseTimelineUpdates()\r\n\t\tself.Player.buildTimeline24(\"update\")\r\n\t\tself.Helper.continueTimelineUpdates()\r\n\t\tself.Player.registerTrigger();\r\n\t\treturn;\r\n\tend\r\n\tif self.playingstatus.scheduleData[1].generatedAt == scheduleData[1].generatedAt then\r\n\t\tself.playingstatus.scheduleData = scheduleData;\r\n\t\tself.playingstatus.scheduleData.vNext = vNext;\r\n\t\tself.Helper.pauseTimelineUpdates()\r\n\t\tself.Player.buildTimeline24(\"update\")\r\n\t\tself.Helper.continueTimelineUpdates()\r\n\t\tself.Player.registerTrigger();\r\n\t\treturn;\r\n\tend\r\nend\r\nself.Player.registerTrigger();\r\n",
     "kind": "func",
     "name": "handleScheduleContinueStates",
     "path": "ISAACPlayer24H.Player.handleScheduleContinueStates"
    },
    {
     "body": "-- disable if Triggered by heartbeat\r\nif self.schedUpdateByHeartbeat == true then \r\n\tself.scheduleUpdateDone = true\r\n\t--pixc.log(\"scheduleUpdateDone done\")\r\n\treturn \r\nend\r\n\r\nif self.triggerHandle == nil then\r\n--self.log(1,\"Trigger!!!!!!!  REG\")\r\nself.triggerHandle = pixc.getRoot().Utils.Timer.setTimeout(\r\n\tfunction()\r\n--\tself.log(1,\"Trigger!!!!!!!\")\r\n\t\tself.triggerHandle = nil\r\n\t\tself.Player.getPlayerInfo()\r\n\tend, self.schedUpdateInterval*1000)\r\nend\r\n",
     "kind": "func",
     "name": "registerTrigger",
     "path": "ISAACPlayer24H.Player.registerTrigger"
    },
    {
     "body": "if self.triggerHandle ~= nil then\r\n\tself.log(1,\"Canceling Trigger\")\r\n\tpixc.getRoot().Utils.Timer.clearInterval(self.triggerHandle);\r\n\tself.triggerHandle = nil\r\nend\r\n",
     "kind": "func",
     "name": "cancelTrigger",
     "path": "ISAACPlayer24H.Player.cancelTrigger"
    },
    {
     "body": "if self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\n\r\n--self.log(1,\"playserstate:\",self.jsonlib.encode(self.playingstatus))\r\n",
     "kind": "func",
     "name": "logPlayState",
     "path": "ISAACPlayer24H.Player.logPlayState"
    },
    {
     "body": "if self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\n\r\nself.log(1,\"timelineStatus:\",self.jsonlib.encode(self.timelineStatus));\r\n",
     "kind": "func",
     "name": "logTimelineStatus",
     "path": "ISAACPlayer24H.Player.logTimelineStatus"
    },
    {
     "body": "if self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nif self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\nlocal beforeCount = 3\r\nlocal elemToPull = tonumber(self.elementsToPull)\r\nlocal elemToPullNext = elemToPull+1\r\nelemToPullNext = math.tointeger(elemToPullNext)\r\nlocal parameter = {}\r\nparameter[\"subsystemExternalId\"] = self.externalIdSchedule\r\nparameter[\"beforeCount\"] = math.tointeger(beforeCount)..\"\"\r\nparameter[\"afterCount\"] = elemToPullNext..\"\"\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\n--local parameter = nil\r\nlocal url = self.url..\"/api/v1/schedule/\"\r\n--self.log(1,url,self.externalId)\r\nlocal success, code, headerDict, content = self.protocol:httpGet(url,parameter)\r\nif(success) then\r\n\tif( code == 200) then\r\n\t\tlocal scheduleData = self.jsonlib.decode(content)\r\n\t\tlocal followingEntry = nil\r\n\t\tif(scheduleData) then\r\n\t\t\tlocal generatedDate = scheduleData[1].generatedAt;\r\n\t\t\tself.log(1,\"Schedule generated at\",generatedDate);\r\n\r\n\t\t\twhile #scheduleData[1].values > elemToPullNext+beforeCount do\r\n\t\t\t\ttable.remove(scheduleData[1].values, #scheduleData[1].values)\r\n\t\t\tend\r\n\t\t\tlocal objectsInList = #scheduleData[1].values\r\n\t\t\tif objectsInList > elemToPull+beforeCount then\r\n\t\t\t\tfollowingEntry = scheduleData[1].values[elemToPullNext+beforeCount]\r\n\t\t\t\ttable.remove(scheduleData[1].values,elemToPullNext+beforeCount)\r\n\t\t\tend\r\n\t\t\tlocal objectsInListNew = #scheduleData[1].values\r\n\r\n\t\t\t--self.log(1,\"SCHEDULE\",self.elementsToPull,elemToPullNextS,objectsInList,objectsInListNew,followingEntry~=nil)\r\n\t\tend\r\n\t\treturn scheduleData,followingEntry;\r\n\telse\r\n\t\tself.Errorhelper.addError(\"Get Schedule failed with code \"..code,\"error\")\r\n\tend\r\nend\r\n",
     "kind": "func",
     "name": "getPlayerSchedule",
     "path": "ISAACPlayer24H.Player.getPlayerSchedule"
    },
    {
     "body": "if self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nif self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\nlocal parameter = {}\r\nparameter[\"subsystemExternalId\"] = self.externalIdSchedule\r\nparameter[\"beforeCount\"] = \"2\"\r\nparameter[\"objectList\"] = \"true\"\r\nif(elementsOverride ~= nil) then\r\n\tparameter[\"afterCount\"] = elementsOverride..\"\"\r\nend\r\nif timeOverride ~= nil then\r\n\r\nend\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\n--local parameter = nil\r\nlocal url = self.url..\"/api/v1/schedule/\"\r\n--self.log(1,url,self.externalId)\r\nlocal success, code, headerDict, content = self.protocol:httpGet(url,parameter)\r\nif(success) then\r\n\tif( code == 200) then\r\n\t\tlocal scheduleData = self.jsonlib.decode(content)\r\n\t\treturn scheduleData;\r\n\telse\r\n\t\tself.Errorhelper.addError(\"getPlayerObjectList failed with code \"..code,\"error\")\r\n\tend\r\nend\r\n",
     "kind": "func",
     "name": "getPlayerScheduleObjectList",
     "params": [
      {
       "name": "elementsOverride",
       "type": ""
      },
      {
       "name": "timeOverride",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Player.getPlayerScheduleObjectList"
    },
    {
     "body": "if self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nif self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\nlocal parameter = {}\r\nparameter[\"subsystemExternalId\"] = self.externalIdSchedule\r\nparameter[\"beforeCount\"] = \"1\"\r\nparameter[\"afterCount\"] = \"0\"\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\n--local parameter = nil\r\nlocal url = self.url..\"/api/v1/schedule/\"\r\n--self.log(1,url,self.externalId)\r\nlocal success, code, headerDict, content = self.protocol:httpGet(url,parameter)\r\nif(success) then\r\n\tif( code == 200) then\r\n\t\tlocal scheduleData = self.jsonlib.decode(content)\r\n\r\n\t\tif(scheduleData) then\r\n\t\t\tlocal generatedDate = scheduleData[1].generatedAt;\r\n\t\tend\r\n\t\treturn scheduleData;\r\n\telse\r\n\t\tself.Errorhelper.addError(\"GetSchedule failed with code\"..code,\"error\")\r\n\tend\r\nend\r\n",
     "kind": "func",
     "name": "getPlayerScheduleLastObject",
     "path": "ISAACPlayer24H.Player.getPlayerScheduleLastObject"
    },
    {
     "body": "--self.Player.logTimelineStatus()\r\nself.Helper.requireJson();\r\nif(self.timelineStatus == nil) then self.timelineStatus = {} end\r\n--self.Helper.logAsJson(\"TLS\",self.timelineStatus)\r\nif(self.timelineStatus == nil) then self.timelineStatus = {} end;\r\nif(self.timelineStatus.objects == nil) then self.timelineStatus.objects = {} end;\r\nself.timelineStatus.actionName =  self()..\"internalTriggerActionTimelineMain\"\r\nself.timelineStatus.triggerEventEntryName =  self()..\"internalTriggerEventTimelineMain\"\r\nif(self.TimelineMain()) then\r\n\tself.timelineStatus.tl = self.TimelineMain().getName()\r\nend\r\nif(self.timelineStatus.tl == nil) then self.log(1,\"Missing Timeline A Reference\") end\r\nself.reservedAction[self.timelineStatus.actionName] = true\r\nself.reservedScheduleEvent[self.timelineStatus.triggerEventEntryName] = true\r\nlocal command = {}\r\ncommand[1] = self()..\".Player.triggerTimelineMain\";\r\ncommand[2] = {}\r\nself.schedule.addAction(self.timelineStatus.actionName, command)\r\n",
     "kind": "func",
     "name": "initTimelineStatus",
     "path": "ISAACPlayer24H.Player.initTimelineStatus"
    },
    {
     "body": "self.Helper.registerLog()\r\nself.Helper.pauseTimelineUpdates()\r\nif note == nil then note = \"\" else note = \" (\"..note..\")\" end\r\nlocal tl = nil;\r\nif( type(index) == 'number') then\r\n    if( index == 1) then\r\n        tl = self.TimelineMain();\r\n    end\r\n    if(tl == nil) then\r\n        self.log(1,self()..\" Clean Timeline Timeline was nil\"..note)\r\n        return\r\n    end\r\nelse\r\n    tl = index\r\nend\r\nif(tl == nil) then return end\r\nlocal removeClipsBefore = function(layer, time)\r\n\tlocal clips = layer.getClips()\r\n\tfor k,v in ipairs(clips) do\r\n\t\tif(v ~= nil) then\r\n\t\t\tif(v.getTime() < time) then\r\n\t\t\t\tv.removeThis()\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\nself.log(1,\"Clean Timeline \"..tl.getName()..note)\r\ntl.stop();\r\ntl.removeCues()\r\nif self.layerBlendName ~= nil then\r\n\tlocal layerBlend = Pixera.Timelines.Layer.getInst(tl.getName() .. \".\" .. self.layerBlendName)\r\n\tif layerBlend == nil or layerBlend.getHandleInt() == 0 then\r\n\t\tlayerBlend = tl.createLayer()\r\n\t\tlayerBlend.setName(self.layerBlendName)\r\n\telse\r\n\t\tlayerBlend.removeClips()\r\n\tend\r\nend\r\nif self.layerPlayName ~= nil then\r\n\tlocal layer = Pixera.Timelines.Layer.getInst(tl.getName() .. \".\" .. self.layerPlayName)\r\n\tif layer == nil or layer.getHandleInt() == 0 then\r\n\t\tlayer = tl.createLayer()\r\n\t\tlayer.setName(self.layerPlayName)\r\n\telse\r\n\t\tlayer.removeClips()\r\n\tend\r\nend\r\n\r\n\r\nlocal comLayer = self.Composition.getCompositionLayers(tl)\r\nfor k,v in pairs(comLayer or {}) do\r\n\tif v ~= nil  and v.getHandleInt() ~= 0 then\t\r\n\t\tv.removeClips()\r\n\tend\r\nend\r\n\r\n\r\n\r\nif(type(index) == 'number' and self.timelineStatus ~= nil) then\r\n\tself.timelineStatus.objects = {}\r\n\tself.timelineStatus.absolutEndTime = nil\r\n\tself.timelineStatus.absoluteStartTime = nil\r\nend\r\nself.Helper.continueTimelineUpdates()\r\nself.Hooks.cleanTimeline(nil,tl);\r\n",
     "kind": "func",
     "name": "cleanTimeline",
     "params": [
      {
       "name": "index",
       "type": ""
      },
      {
       "name": "note",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Player.cleanTimeline"
    },
    {
     "body": "\r\n--\teSeqClipPlayModeLockToTime = 1,\r\n--\teSeqClipPlayModePlayOnce = 2,\r\n--\teSeqClipPlayModeLoop = 3,\r\n--\teSeqClipPlayModePauseAtInpoint = 4,\r\n--\teSeqClipPlayModeLockToTimeNoLoop = 5\r\n\r\nlocal resource = nil\r\nif self.mediaOverlayContentFolderHandle == nil then\r\n\tself.Errorhelper.addError(\"Media Overlay Media Ressouce Folder found\",\"error\")\r\n\treturn nil\r\nend\r\n\r\nif self.transitionMode == \"Media Overlay Fixed\" then \r\n\tlocal resources =  self.mediaOverlayContentFolderHandle.getResources();\r\n\r\n\tif resources ~= nil then\r\n\t\tfor k,v in ipairs(resources) do\r\n\t\t\tlocal nameH = v.getName()\r\n\t\t\tif(nameH == self.mediaOverlayFixedResourceName) then\r\n\t\t\t\tresource = v;\r\n\t\t\tend\r\n\t\tend \t\t\r\n\tend\r\n    if(resource == nil) then\r\n\t   self.Errorhelper.addError(\"Fixed Media Overlay Media with name \"..self.mediaOverlayFixedResourceName..\" not found\",\"error\")\r\n\t    return nil\r\n    end\r\nelse \r\n    if self.transitionMode == \"Media Overlay Random\" then \r\n        local resources =  self.mediaOverlayContentFolderHandle.getResources();\r\n        if resources ~= nil then\r\n            local count = #resources;\r\n            if (count == 0) then\r\n               self.Errorhelper.addError(\"Media Overlay Resource Folder empty\",\"error\")\r\n                return nil\r\n            end\r\n            local rand = math.random(1,count)\r\n            resource = resources[rand]\r\n        end\r\n    end\r\nend\r\n\r\nreturn resource\r\n",
     "kind": "func",
     "name": "getBlendResource",
     "params": [
      {
       "name": "gapDuration",
       "type": ""
      },
      {
       "name": "splitBridge",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.Player.getBlendResource"
    },
    {
     "body": "if up == nil or down == nil then return end\r\n\r\nlocal hdlUp = up.getHandleInt();\r\nlocal hdlDown = down.getHandleInt();\r\nlocal idxUp = 0;\r\nlocal idxDown = 0;\r\n\r\nlocal updateIdx = function(hdlu,hdld) \r\n\tlocal timelines = self.Pixera().Timelines.getTimelines()\r\n\tlocal iUp = 0;\r\n\tlocal iDown = 0;\r\n\tfor k = 1, #timelines, 1 do\r\n\t\tif timelines[k].getHandleInt() == hdlu then\r\n\t\t\tiUp = k;\r\n\t\tend\r\n\t\tif timelines[k].getHandleInt() == hdld then\r\n\t\t\tiDown = k;\r\n\t\tend\r\n\tend\r\n\treturn iUp,iDown;\r\nend\r\nlocal count = 0\r\nwhile true do\r\n\tcount = count+1\r\n\tidxUp, idxDown = updateIdx(hdlUp,hdlDown)\r\n\tif( idxUp == 0 or idxDown == 0) then\r\n\t\treturn\r\n\tend\r\n\t\r\n\tif( idxUp > idxDown) or count == 100 then\r\n\t\tup.moveInRenderOrder(false)\r\n\telse\r\n\t\treturn\r\n\tend\r\nend\r\n",
     "kind": "func",
     "name": "reorderTimeline",
     "params": [
      {
       "name": "up",
       "type": ""
      },
      {
       "name": "down",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Player.reorderTimeline"
    },
    {
     "body": "return self.playingstatus.scheduleObjectList\r\n",
     "kind": "func",
     "name": "getScheduleObjectListLocal",
     "path": "ISAACPlayer24H.Player.getScheduleObjectListLocal"
    },
    {
     "body": "local t = optionalType;\r\nif(optionalType == \"all\") then\r\n\tt = \"all\"\r\nend\r\nlocal video = {};\r\nlocal image = {};\r\nlocal audio = {};\r\nlocal other = {};\r\nlocal isType = function(type, object)  return type == \"video\"; end\r\n\r\nfor k,v in ipairs(objectList) do\r\n    if t == \"all\" or isType(\"video\",v) == true then\r\n\t\tlocal obj = v.object;\r\n\t\t\r\n\r\n\t\tif string.sub(obj, -1, -1) == \"/\" then\r\n\t\t\tobj=string.sub(obj, 1, -2)\r\n\t\tend\r\n\r\n\r\n        table.insert(video,obj);\r\n    end\r\n    if t == \"all\" or isType(\"image\",v) == true then\r\n        table.insert(image,v.object);\r\n    end\r\n    if t == \"all\" or isType(\"audio\",v) == true then\r\n        table.insert(audio,v.object);\r\n    end\r\n    if t == \"all\" or isType(\"other\",v) == true then\r\n        table.insert(other,v.object);\r\n    end\r\nend\r\n--self.log(1,\"OBJECLISTS\",pixcCommon.toJson(video),pixcCommon.toJson(image),pixcCommon.toJson(audio),pixcCommon.toJson(other))\r\nreturn video,image,audio,other;\r\n",
     "kind": "func",
     "name": "getObjectsListAsArray",
     "params": [
      {
       "name": "optionalType",
       "type": "string"
      },
      {
       "name": "objectList",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Player.getObjectsListAsArray"
    },
    {
     "body": "--self.instantPlayStatus = \"Stop\"\r\ntl = self.TimelineMain();\r\nself.Player.run24Timeline(self.instantPlayFadeTimeS,true)\r\n",
     "kind": "func",
     "name": "defaultStopInstant",
     "path": "ISAACPlayer24H.Player.defaultStopInstant"
    },
    {
     "body": "if self.enableInstantPlay == false then return end\r\nif playableInfo ~= nil then\r\n\tself.instantPlayableType = \"composition\"\r\n\tself.instantPlayableInfo = playableInfo\r\n\tself.instantPlayComposition = command\r\nend\r\nif self.instantIsCustom ~= nil then\r\n\tself.instantIsCustom = isCustom\r\nend\r\n\r\n\r\n\r\nif(self.instantPlayStatus == \"Play\") then\r\n\t-- Already Playing the right thing\r\n    if(self.instantPlayMedia == name and self.instantPlayMedia ~=nil ) then\r\n        if((self.instantPlayStatusMode == \"Loop\" and loop == true) or (self.instantPlayStatusMode == \"Once\" and loop == false)) then\r\n            return\r\n        end\r\n    end\r\nend\r\nif name == nil and loop == nil then\r\n\t-- handle Waiting\r\n\tif self.instantPlayStatus == \"Waiting\" then\r\n\t\tname = self.instantPlayMedia;\r\n\t\tcommand = self.instantPlayComposition\r\n\telse\r\n\t\treturn\r\n\tend\r\nend\r\n\r\nlocal tlInstant = self.TimelineInstant()\r\nif(tlInstant == nil) then\r\n    self.log(1,\"InstantPlay failed: missing Timeline\")\r\n\treturn\r\nend\r\n\r\nself.Player.cleanTimeline(tlInstant)\r\nif loop ~= nil then\r\n\tif (loop == true) then\r\n\t\tself.instantPlayStatusMode = \"Loop\";\r\n\telse\r\n\t\tself.instantPlayStatusMode = \"Once\";\r\n\tend\r\nelse\r\n\tif self.instantPlayStatusMode == \"Loop\" then\r\n\t\tloop = true\r\n\telse\r\n\t\tloop = false\r\n\tend\r\nend\r\nself.instantPlayMedia = name;\r\nself.instantPlayComposition = command\r\n\r\n\r\n--pixc.log(\"img\",isImage)\t\r\nif( command ~= nil and command.data ~= nil) then\r\n\tfor k,v in pairs(command.data) do\r\n\r\n\t\tlocal layer,info = self.Composition.getLayerId(k)\r\n\t\tlocal typ,nr,uid = self.Composition.helper.parseId(k)\r\n\t\tlocal resource = nil\r\n\t\tif typ == nil  or typ == \"med\" then --defautl compostion or media\r\n\t\t\tlocal resource = self.ContentHandling.getHandleFormMedia(\"video\",v.objectName) \r\n\t\t\tif resource ~= nil then\r\n\t\t\t\tif self.checkPendingTransfers == false then \t\t\t\t\r\n\t\t\t\t\tself.instantPlayStatus = \"Play\";\t\r\n\t\t\t\telse\r\n\t\t\t\t\tif( command ~= nil and command.data ~= nil) then\r\n\t\t\t\t\t\tfor k,v in pairs(command.data) do\r\n\t\t\t\t\t\t\tif(v.objectName ~= nil) then\r\n\t\t\t\t\t\t\t\tlocal resource = self.ContentHandling.getHandleFormMedia(\"video\",v.objectName) \r\n\t\t\t\t\t\t\t\tif res.getHasPendingTransfer() == true then\r\n\t\t\t\t\t\t\t\t\tself.instantPlayStatus = \"Waiting\";\t\r\n\t\t\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\tself.instantPlayStatus = \"Play\";\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\telse\r\n\t\t\t\tif self.instantPlayWaitForMedia == true then\r\n\t\t\t\t\tself.instantPlayStatus = \"Waiting\";\t\r\n\t\t\t\t\tself.log(1,\"Instant Play Resource not found, waiting: \",name)\r\n\t\t\t\t\tif self.schedUpdateByHeartbeat == true then \r\n\t\t\t\t\t\tif self.scheduleUpdateActive == false then\r\n\t\t\t\t\t\t\tself.scheduleUpdateActive = true\r\n\t\t\t\t\t\t\tself.log(1,\"Early trigger of update, because of missing Instant play media\")\r\n\t\t\t\t\t\t\tself.Player.getPlayerInfo()\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\tend\r\n\t\t\t\telse\r\n\t\t\t\t\tself.log(1,\"Instant Play Resource not found, ignore: \",name)\r\n\t\t\t\t\tself.instantPlayStatus = \"Stop\";\r\n\t\t\t\t\tself.instantPlayMedia = \"\";\r\n\t\t\t\t\treturn\r\n\t\t\t\tend\r\n\t\t\tend\t\r\n\t\tend \r\n\tend\r\nend\r\n\r\nself.Player.cleanTimeline(tlInstant)\r\ntlInstant.setCurrentTime(0)\r\ntlInstant.removeCues()\r\n\r\nlocal fps = tlInstant.getFps();\r\nlocal duration = 0\r\nlocal time = 0;\r\nlocal endTime = 0;\r\nif( self.instantPlayableInfo ~= nil) then\r\n\tduration = self.instantPlayableInfo.duration/1000;\r\nend\r\nendTime = time + duration\r\nfor k,v in pairs(command.data) do\r\n\tlocal layer,info = self.Composition.getLayerId(k,true)\r\n\tlocal typ,nr,uid = self.Composition.helper.parseId(k)\r\n\tlocal resource = nil\r\n\tif typ == nil  or typ == \"med\" then --defautl compostion or media\r\n\t\tif(v.objectName ~= nil) then\r\n\t\t\tlocal resource = self.ContentHandling.getHandleFormMedia(\"video\",v.objectName) \r\n\t\t\t\tif(layer~= nil and resource ~= nil) then\r\n\t\t\t\tlocal clip = layer.createClipAtTime(0)\r\n\t\t\t\tif clip ~= nil then\r\n\t\t\t\t\tclip.setTime(time * fps)\r\n\t\t\t\t\tclip.assignResource(resource.getId())\r\n\t\t\t\t\tclip.setDuration(duration * fps)\r\n\t\t\t\t\tif duration > 2 then\r\n\t\t\t\t\t\ttime = time - 1\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\tif typ == \"lis\" then\r\n\t\tresource = self.ContentHandling.getLiveInput(v);\r\n\r\n\t\tlocal durationLive = command.data[info.liveDurationId];\r\n\t\tif(durationLive < 1) then\r\n\t\t\tdurationLive = duration\r\n\t\tend\r\n\r\n\t\tif(layer~= nil and resource ~= nil) then\r\n\t\t\tlocal clip = layer.createClipAtTime(0)\r\n\t\t\tif clip ~= nil then\r\n\t\t\t\tclip.setTime(time * fps)\r\n\t\t\t\tclip.assignResource(resource.getId())\r\n\t\t\t\tclip.setDuration(durationLive * fps/1000)\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\nif endTime > 1  then\r\n    if loop == true then\r\n        local cue = tlInstant.createCue(\"Loop\", endTime * fps - 1, 4)\r\n        if cue ~= nil then\r\n            cue.setJumpGoalTime(0)\r\n        end\r\n    else\r\n\t\tlocal t = (endTime -self.instantPlayFadeTimeS) * fps;\r\n\t\tif(t < 1) then\r\n\t\t\tt = 1\r\n\t\tend\r\n        local cue = tlInstant.createCue(\"FadeoutAndStop\", t, 1)\r\n        if(cue) then\r\n\t\t\tcue.setCommand(\"pixc\",self()..\".Player.stopPlayInstant\")\r\n\t\tend\r\n    end\r\nend\r\nlocal TA = self.TimelineMain()\r\nself.Player.reorderTimeline(tlInstant,self.TimelineMain());\r\ntlInstant.setOpacity(0)\r\ntlInstant.play()\r\ntlInstant.startOpacityAnimation(true,self.instantPlayFadeTimeS * tlInstant.getFps())\r\nTA.startOpacityAnimation(false,self.instantPlayFadeTimeS*TA.getFps())\r\nif(self.stopTlInstantPlay == true) then\r\n\tself.Player.cleanTimeline(1)\r\n\tself.playingstatus.state = \"none\"\r\nend\r\n",
     "kind": "func",
     "name": "startPlayInstantComposition",
     "params": [
      {
       "name": "name",
       "type": ""
      },
      {
       "name": "loop",
       "type": ""
      },
      {
       "name": "playableInfo",
       "type": ""
      },
      {
       "name": "command",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Player.startPlayInstantComposition"
    },
    {
     "body": "if self.enableInstantPlay == false then return end\r\nif name == nil and loop == nil and playableInfo == nil then\r\n\tif(self.instantPlayableType == \"composition\") then\r\n\t\tself.Player.startPlayInstantComposition()\r\n\tend\r\nend\r\nif playableInfo ~= nil then\r\n\tself.instantPlayableType = \"normal\"\r\n\tself.instantPlayableInfo = playableInfo\r\nend\r\nif self.instantIsCustom ~= nil then\r\n\tself.instantIsCustom = isCustom\r\nend\r\nif(self.instantPlayStatus == \"Play\") then\r\n\t-- Already Playing the right thing\r\n    if(self.instantPlayMedia == name and name ~= nil) then\r\n        if((self.instantPlayStatusMode == \"Loop\" and loop == true) or (self.instantPlayStatusMode == \"Once\" and loop == false)) then\r\n            return\r\n        end\r\n    end\r\nend\r\nif name == nil and loop == nil then\r\n\t-- handle Waiting\r\n\tif self.instantPlayStatus == \"Waiting\" then\r\n\t\tname = self.instantPlayMedia;\r\n\telse\r\n\t\treturn\r\n\tend\r\nend\r\n\r\nlocal tlInstant = self.TimelineInstant()\r\nif(tlInstant == nil) then\r\n    self.log(1,\"InstantPlay failed: missing Timeline\")\r\n\treturn\r\nend\r\n\r\nself.Player.cleanTimeline(tlInstant)\r\nif loop ~= nil then\r\n\tif (loop == true) then\r\n\t\tself.instantPlayStatusMode = \"Loop\";\r\n\telse\r\n\t\tself.instantPlayStatusMode = \"Once\";\r\n\tend\r\nelse\r\n\tif self.instantPlayStatusMode == \"Loop\" then\r\n\t\tloop = true\r\n\telse\r\n\t\tloop = false\r\n\tend\r\nend\r\nself.instantPlayMedia = name;\r\nlocal isImage = false\r\nlocal res = self.ContentHandling.getHandleFormMedia(\"video\",self.instantPlayMedia)\r\nif(res == nil ) then\r\n\tres = self.ContentHandling.getHandleFormMedia(\"image\",self.instantPlayMedia)\r\n\tif(res ~= nil) then\r\n\t\tisImage = true\r\n\tend\r\nend\r\n\r\n--pixc.log(\"img\",isImage)\r\nif(self.instantIsCustom ~= true ) then \r\n\tif res == nil then\r\n\t\t-- Media missing\r\n\t\tif self.instantPlayWaitForMedia == true then\r\n\t\t\tself.instantPlayStatus = \"Waiting\";\t\r\n\t\t\tself.log(1,\"Instant Play Resource not found, waiting: \",name)\r\n\t\t\tif self.schedUpdateByHeartbeat == true then \r\n\t\t\t\tif self.scheduleUpdateActive == false then\r\n\t\t\t\t\tself.scheduleUpdateActive = true\r\n\t\t\t\t\tself.log(1,\"Early trigger of update, because of missing Instant play media\")\r\n\t\t\t\t\tself.Player.getPlayerInfo()\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tself.log(1,\"Instant Play Resource not found, ignore: \",name)\r\n\t\t\tself.instantPlayStatus = \"Stop\";\r\n\t\t\tself.instantPlayMedia = \"\";\r\n\t\tend\r\n\t\treturn\r\n\telse\r\n\t\t-- media there\r\n\t\tif self.checkPendingTransfers == false then \t\t\t\t\r\n\t\t\tself.instantPlayStatus = \"Play\";\t\r\n\t\telse\r\n\t\t\tif res.getHasPendingTransfer() == true then\r\n\t\t\t\tself.instantPlayStatus = \"Waiting\";\t\r\n\t\t\t\treturn\r\n\t\t\telse \r\n\t\t\t\tself.instantPlayStatus = \"Play\";\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\nself.log(1,\"Ressource Instant Play Resource\", res.getName(),res)\r\nlocal layer = Pixera.Timelines.Layer.getInst(tlInstant.getName() .. \".\" .. self.layerPlayName)\r\nif layer == nil or layer.getHandleInt() == 0 then\r\n    self.instantPlayStatus = \"Stop\";\r\n    self.instantPlayMedia = \"\";\r\n\treturn\r\nend\r\nself.Player.cleanTimeline(tlInstant)\r\ntlInstant.setCurrentTime(0)\r\nlocal fps = tlInstant.getFps();\r\nlocal duration = 0\r\nlocal time = 0;\r\nlocal endTime = 0;\r\nif( self.instantPlayableInfo ~= nil) then\r\n\tduration = self.instantPlayableInfo.duration/1000;\r\nelse\r\n\tduration = res.getDuration()\r\nend\r\nif duration > 0 then\r\n\tif duration < 2 then\r\n\t\tduration = 10\r\n\tend\r\n    \r\n\tlocal clip = layer.createClip()\r\n\tif clip ~= nil then\r\n\t\tclip.setDuration(duration * fps)\r\n\t\tclip.setTime(time * fps)\r\n\t\tif( self.instantIsCustom == true) then\r\n\t\t\tself.Hooks.customPlayable(self.instantPlayableInfo.command,tlInstant,time)\r\n\t\telse\r\n\t\t\tclip.assignResource(res.getId())\r\n\t\tend\r\n\t\tclip.setPlayMode(5)\t\r\n\t\tendTime = time + duration\r\n\t\ttime = endTime\r\n\t\tif duration > 2 then\r\n\t\t\ttime = time - 1\r\n\t\tend\r\n\tend\r\nend\r\ntlInstant.removeCues()\r\nif endTime > 1  then\r\n    if loop == true then\r\n        local cue = tlInstant.createCue(\"Loop\", endTime * fps - 1, 4)\r\n        if cue ~= nil then\r\n            cue.setJumpGoalTime(0)\r\n        end\r\n    else\r\n\t\tlocal t = (endTime -self.instantPlayFadeTimeS) * fps;\r\n\t\tif(t < 1) then\r\n\t\t\tt = 1\r\n\t\tend\r\n        local cue = tlInstant.createCue(\"FadeoutAndStop\", t, 1)\r\n        if(cue) then\r\n\t\t\tcue.setCommand(\"pixc\",self()..\".Player.stopPlayInstant\")\r\n\t\tend\r\n    end\r\nend\r\nlocal TA = self.TimelineMain()\r\nself.Player.reorderTimeline(tlInstant,self.TimelineMain());\r\ntlInstant.setOpacity(0)\r\ntlInstant.play()\r\ntlInstant.startOpacityAnimation(true,self.instantPlayFadeTimeS * tlInstant.getFps())\r\nTA.startOpacityAnimation(false,self.instantPlayFadeTimeS*TA.getFps())\r\nif(self.stopTlInstantPlay == true) then\r\n\tself.Player.cleanTimeline(1)\r\n\tself.playingstatus.state = \"none\"\r\nend\r\n",
     "kind": "func",
     "name": "startPlayInstant",
     "params": [
      {
       "name": "name",
       "type": "string"
      },
      {
       "name": "loop",
       "type": "bool"
      },
      {
       "name": "playableInfo",
       "type": ""
      },
      {
       "name": "isCustom",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Player.startPlayInstant"
    },
    {
     "body": "\r\n\r\nlocal tl = self.TimelineInstant()\r\nif(tl == nil) then\r\n\treturn\r\nend\r\n\r\n--pixc.log(\"StopPlayInstant\")\r\n\r\nif self.enableInstantPlay == false then\r\n\treturn \r\nend\r\nlocal TA = self.TimelineMain()\r\nTA.startOpacityAnimation(true,self.instantPlayFadeTimeS*TA.getFps())\r\ntl.startOpacityAnimation(false,self.instantPlayFadeTimeS * tl.getFps())\r\nUtils.Timer.sleep(self.instantPlayFadeTimeS*1000+10)\r\nself.instantPlayStatus = \"Stop\";\r\nself.Player.cleanTimeline(tl);\r\n\r\n--self.Player.run24Timeline(self.instantPlayFadeTimeS,true)\r\nself.instantPlayStatusLoop = \"\";\r\nself.instantPlayMedia = \"\";\r\nself.instantIsCustom = nil\r\nself.instantPlayableInfo  = nil\r\ntl.stop()\r\n\r\nif self.stopTlInstantPlay == true and self.schedUpdateByHeartbeat == true then \r\n\tif self.scheduleUpdateActive == false then\r\n\t\tself.scheduleUpdateActive = true\r\n\t\tself.log(1,\"Early trigger of update, because of Instant play stopped, and Stop Timelines is active\")\r\n\t\tself.Player.getPlayerInfo()\r\n\tend\r\nend\r\n\r\n\r\n\r\n",
     "kind": "func",
     "name": "stopPlayInstant",
     "params": [
      {
       "name": "skipModifyNow",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Player.stopPlayInstant"
    },
    {
     "body": "--\r\nif self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nself.Helper.requireJson();\r\nlocal parameter = {}\r\nparameter[\"subsystemExternalId\"] = self.externalId\r\nparameter[\"forceCached\"] = \"true\"\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\n--local parameter = nil\r\nlocal url = self.url..\"/api/v1/playables/\"\r\n--self.log(1,url,self.externalId)\r\nlocal success, code, headerDict, content = self.protocol:httpGet(url,parameter)\r\nif(success) then\r\n\t--self.log(1,code)\r\n\t--self.log(1,content)\r\n\tif( code == 200) then\r\n\t\tlocal result = {};\r\n\t\tlocal custom = {};\r\n\t\t\r\n\t\tlocal mediaParsed = self.jsonlib.decode(content)\r\n\t\t\r\n\t\tif mediaParsed == nil then return nil end\r\n\t\tfor _, v in ipairs(mediaParsed) do\r\n\t\t\tlocal type,name,command = self.Player.parseCommand(v.command)\r\n\t\t\tif( type == \"video\") then\r\n\t\t\t\ttable.insert(result,name);\r\n\t\t\tend\r\n\t\t\tif type == \"custom\" then \r\n\t\t\t\ttable.insert(custom,command);\r\n\t\t\tend\t\r\n\t\tend \r\n\t\tself.localInstantCustomPlayables = custom\r\n\t\tself.localInstantPlayables = result\r\n\t\treturn result;\r\n\telse\r\n\t\tself.log(1,\"getPlayables failed with code\", code)\r\n\tend\r\nelse\r\n\tself.log(1,\"getPlayables failed\")\r\nend\r\n",
     "kind": "func",
     "name": "getInstantPlayables",
     "path": "ISAACPlayer24H.Player.getInstantPlayables"
    },
    {
     "body": "self.Helper.requireJson()\r\n--pixc.log(self.jsonlib.encode(msg))\r\nfor k,v in ipairs(msg) do\r\n\tif v.type ~= nil and v.type == \"forcePlay\" then\r\n\t\tlocal  doLoop =  false;\r\n\t\tif v.playType == \"infinite\" then\r\n\t\t\tdoLoop = true;\r\n\t\tend\r\n\t\tif v.payload ~= nil then\r\n\t\t\tif v.payload.playable ~= nil then\r\n\t\t\t\tif v.payload.playable.command ~= nil then\r\n\t\t\t\t\t\r\n\t\t\t\t\tlocal type, name,command = self.Player.parseCommand(v.payload.playable.command)\r\n\t\t\t\t\tif type == \"video\" then\r\n\t\t\t\t\t\tself.Player.startPlayInstant(name,doLoop,v.payload.playable)\r\n\t\t\t\t\t\tself.waitingCounter = 0\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\tend\r\n\t\t\t\t\tif(type == \"composition\") then\r\n\t\t\t\t\t\tself.Player.startPlayInstantComposition(v.payload.playable._id..\"\",doLoop,v.payload.playable,command)\r\n\t\t\t\t\t\tself.waitingCounter = 0\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\tend\r\n\t\t\t\t\tif(type == \"custom\") then\r\n\t\t\t\t\t\tself.Player.startPlayInstant(name,doLoop,v.payload.playable,true)\r\n\t\t\t\t\t\tself.waitingCounter = 0\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\r\n\tif v.type ~= nil and v.type == \"forceStop\" then\r\n\t\tself.Player.stopPlayInstant()\r\n\t\tself.waitingCounter = 0\r\n\t\treturn\r\n\tend\r\n\r\nend\t\r\n\r\nif self.instantPlayStatus == \"Waiting\" then\r\n\tif self.waitingCounter > 5 then\r\n\t\tself.Player.startPlayInstant(nil,nil,nil,nil)\r\n\t\tself.waitingCounter = 0\r\n\telse\r\n\t\tself.waitingCounter = self.waitingCounter + 1\r\n\tend\r\nend\r\n",
     "kind": "func",
     "name": "executeHeartbeatMessage",
     "params": [
      {
       "name": "msg",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.Player.executeHeartbeatMessage"
    },
    {
     "body": "--pixc.log(\"Run24\")\r\nif self.forceStop == true then return end\r\nlocal tl = self.TimelineMain()\r\nlocal fps = tl.getFps()\r\nlocal cue = self.Helper.moveCue(tl,\"Loop\",self.loopCue24Pos,true)\r\nif(cue ~= nil) then\r\n\tcue.setOperation(4);\r\n\tcue.setJumpGoalTime(0)\r\nelse\r\n\t--pixc.log(\"Run24ss\",cue)\r\n\tself.log(1,\"Move Loop Cue failed\")\r\n\treturn\r\nend\r\n\r\n--pixc.log(\"Run24c\")\r\nif blendDurationS == nil then\r\n\tblendDurationS = 0\r\nend\r\nif(blendDurationS < 0) then\r\n\tblendDurationS = 0\r\nend\r\n\r\n\r\n\r\n\r\n--local cue = tl.createCue(\"Loop\", self.loopCue24Pos, 4)\r\nlocal tShould  = self.Helper.secondsToday()*fps\r\n\r\nlocal tIs = tl.getCurrentTime()\r\n\r\nif blendDurationS > 0.01 then\r\n\tlocal goalTime = tShould--+blendDurationS*tl.getFps()\r\n\twhile ( goalTime > self.loopCue24Pos) do\r\n\t\tgoalTime = goalTime - self.loopCue24Pos\r\n\tend\r\n\t--pixc.log(\"blend Run24aa\")\r\n\ttl.blendToTime(goalTime,blendDurationS*tl.getFps())\r\n\t\r\nelse\r\n\tif tShould > self.loopCue24Pos -5 then\r\n\t\ttl.setCurrentTime(0);\r\n\t\ttl.play();\r\n\telse\r\n\t\tif tIs < tShould +30 and tIs > tShould - 30 then\r\n\t\t\t\r\n\t\telse\r\n\t\t\ttl.play();\r\n\t\t\ttl.setCurrentTime(tShould);\r\n\t\tend\r\n\tend\r\nend\r\ntl.play();\r\n",
     "kind": "func",
     "name": "run24Timeline",
     "params": [
      {
       "name": "blendDurationS",
       "type": ""
      },
      {
       "name": "overrideInstant",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Player.run24Timeline"
    },
    {
     "body": "if self.loopClip ~= nil then\r\n\tself.loopClip.removeThis()\r\n\tself.loopClip = nil\r\nend\r\nself.Helper.pauseTimelineUpdates()\r\nlocal rmTimelinedataItem = function(item)\r\n\tif item ~= nil then\r\n\t\tfor k,v in pairs(item.clips) do\r\n\r\n\t\t\tif(v ~= nil) then\r\n\t\t\t\tv.removeThis()\r\n\t\t\tend\r\n\t\tend\r\n\t\titem.clips = {}\r\n\t\tfor k,v in pairs(item.clipsSplit) do\r\n\r\n\t\t\tif(v ~= nil) then\r\n\t\t\t\tv.removeThis()\r\n\t\t\tend\r\n\t\tend\r\n\t\titem.clipsSplit = {}\r\n\t\t\r\n\tend\r\nend\r\nlocal removeOldTimeLineData = function()\r\n\tlocal tl1 = self.TimelineMain();\r\n\tlocal nowUnixTs = os.time(os.date(\"*t\"))\r\n\tlocal fps = tl1.getFps()\r\n\r\n\tlocal rmFunc = function(t,i,j,ext) \r\n\t\tlocal off = t[i].endTimeUnix + (self.removeMinDurationAfterEnd*60);\r\n\t\tif(nowUnixTs > off) then\r\n\t\t\treturn false\r\n\t\telse\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\n\r\n\tself.helper.arrayRemove(self.timelineStatus.objects,rmFunc,now,rmTimelinedataItem)\r\nend\r\nlocal removeTimelineDataUntilIndexFromEnd = function(index)\r\n\tlocal count = #self.timelineStatus.objects\r\n\tfor i = count, index,-1 do\r\n\t\tif(self.timelineStatus.objects[i] ~= nil ) then\r\n\t\t\trmTimelinedataItem(self.timelineStatus.objects[i])\r\n\t\t\tself.timelineStatus.objects[i] = nil\r\n\t\tend\r\n\tend\r\nend\r\n\r\n\r\nlocal addClipToLayer = function (layerB,duration,startFullBlend,fps,blendRessource)\r\n\t--self.log(1,\"addClipToLayer\",layerB,duration,startFullBlend,fps,blendRessource,playmode,centerMedia)\r\n\tlocal centerMedia = true\r\n\r\n\tlocal fullDuration = self.dissolveInMs + duration+ self.dissolveHighMs+ self.dissolveOutMs\r\n\tlocal timeStartBlend =startFullBlend - self.dissolveInMs\r\n\t\r\n\tlocal resourceDuration = blendRessource.getDuration()*1000\r\n\tlocal isImage =false;\r\n\tlocal applyDisolve = true;\r\n\r\n\tif resourceDuration < 0.1  then\r\n\t\tcenterMedia = false\r\n\t\tapplyDisolve = true   \r\n\telse\r\n\t\tapplyDisolve = self.applyDisolveOnVideo\r\n\t\tif self.limitVideoBlendDuration == true then\r\n\t\t\tcenterMedia = false\r\n\t\tend \r\n\tend\r\n\r\n--\teSeqClipPlayModeLockToTime = 1,\r\n--\teSeqClipPlayModePlayOnce = 2,\r\n--\teSeqClipPlayModeLoop = 3,\r\n--\teSeqClipPlayModePauseAtInpoint = 4,\r\n--\teSeqClipPlayModeLockToTimeNoLoop = 5\r\n\tlocal dissolveInMs =  self.dissolveInMs\r\n\tlocal dissolveHighMs = self.dissolveHighMs\r\n\tlocal dissolveOutMs = self.dissolveOutMs\r\n\tlocal dissolveHighOffsetMs = self.dissolveHighOffsetMs\r\n\tlocal clip;\r\n\tif centerMedia == true then --and fullDuration > resourceDuration then\r\n\t\tif duration > 10 then \r\n\t\t\tfullDuration = dissolveInMs + dissolveHighMs+ dissolveOutMs + duration\r\n\t\telse\r\n\t\t\tdissolveHighMs = resourceDuration - dissolveInMs -dissolveOutMs\r\n\t\t\tif dissolveHighMs < 0 then\r\n\t\t\t\tdissolveInMs = dissolveInMs +(dissolveHighMs/2)\r\n\t\t\t\tdissolveOutMs = dissolveOutMs  +(dissolveHighMs/2)\r\n\t\t\t\tdissolveHighMs = 0;\r\n\t\t\tend\r\n\t\t\tfullDuration = dissolveInMs + dissolveHighMs+ dissolveOutMs\r\n\t\tend\r\n\t\t\r\n\t\tlocal diff = fullDuration- resourceDuration;\r\n\t\tlocal offset = diff/2;\r\n\t\t\r\n\t\tlocal t = 1\r\n\t\t\r\n\t\t--self.log(1,\"Disolve\",blendRessource.getName(),applyDisolve, self.applyDisolveOnVideo  )\r\n\t\tif(applyDisolve == true ) then\r\n\t\t\t--self.log(1,\"AAAA\",blendRessource.getName())\r\n\t\t\tt = (timeStartBlend+dissolveHighOffsetMs + offset + (dissolveHighMs*-1)/2)/1000 * fps;\r\n\t\telse\r\n\t\t\tt = (startFullBlend + (resourceDuration/2*-1))/1000 * fps\r\n\t\t\t--t = timeStartBlend * fps\r\n\t\t\t-- self.log(1,\"BBBB\",blendRessource.getName(),timeStartBlend,resourceDuration,t)\r\n\t\t\t\r\n\t\tend\r\n\r\n\t\tif t == 0 then t = 1 end\r\n\t\tt =  self.calculateLoopPosition(t)\r\n\t\tclip = layerB.createClipAtTime(t)\r\n\t\tif clip ~= nil then\r\n\t\t\tclip.setDuration(resourceDuration/1000 * fps)\t\r\n\t\t\t--clip.setTime(t)\r\n\t\t\tif blendRessource ~= nil then\r\n\t\t\t\tclip.assignResource(blendRessource.getId())\t\t\r\n\t\t\tend\r\n\t\t\tclip.setDuration(resourceDuration/1000 * fps)\t\r\n\t\t\tclip.setPlayMode(5)\t\r\n\r\n\t\t\tif(dissolveInMs > 0 or dissolveOutMs > 0) and applyDisolve == true then\r\n\t\t\t\tclip.createEvent('Opacity', 0 * fps, 0)\r\n\t\t\t\tclip.createEvent('Opacity', dissolveInMs/1000 * fps ,1)\r\n\t\t\t\tclip.createEvent('Opacity', ( dissolveInMs +dissolveHighMs+duration)/1000 * fps ,1)\r\n\t\t\t\tclip.createEvent('Opacity', resourceDuration/1000 * fps, 0)\r\n\t\t\tend\r\n\t\tend\r\n\telse\r\n\t\tlocal t = (timeStartBlend+self.dissolveHighOffsetMs + (self.dissolveHighMs*-1)/2)/1000 * fps;\r\n\t\tif t == 0 then t = 1 end\r\n\t\tt =  self.calculateLoopPosition(t)\r\n\t\tclip = layerB.createClipAtTime(t)\r\n\t\tif clip ~= nil then\r\n\t\t\tclip.setDuration(fullDuration/1000 * fps)\t\r\n\t\t\t--clip.setTime(t)\r\n\t\t\tif blendRessource ~= nil then\r\n\t\t\t\tclip.assignResource(blendRessource.getId())\t\r\n\t\t\tend\t\r\n\t\t\tclip.setDuration(fullDuration/1000 * fps)\t\r\n\t\t\tclip.setPlayMode(5)\t\r\n\t\t\tif(self.dissolveInMs > 0 or self.dissolveOutMs > 0) and applyDisolve == true then\r\n\t\t\t\tclip.createEvent('Opacity', 0 * fps, 0)\r\n\t\t\t\tclip.createEvent('Opacity', self.dissolveInMs/1000 * fps ,1)\r\n\t\t\t\tclip.createEvent('Opacity', ( self.dissolveInMs +self.dissolveHighMs+duration)/1000 * fps ,1)\r\n\t\t\t\tclip.createEvent('Opacity', fullDuration/1000 * fps, 0)\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\treturn clip;\r\nend\r\n\r\nlocal createBlendClip = function (layer, startFullBlendO, duration,fps)\r\n\tif self.transitionMode == \"Cut\" then return end\r\n\tif layer ~= nil and layer.getHandleInt() ~= 0 then\r\n\t\t\r\n\t\tlocal blendRessource1\r\n\t\tlocal playmode1\r\n\t\tlocal centerMedia1\r\n\t\tlocal blendRessource2\r\n\t\tlocal playmode2\r\n\t\tlocal centerMedia2\t\r\n\t\tlocal gapDur = duration\r\n\t\tlocal splitBridge = false\r\n\t\t if(duration > 10 and duration > self.maximumBridgeGapS*1000) then\r\n\t\t\tsplitBridge = true\r\n\t\t\tgapDur = 0\r\n\t\tend\r\n\t--\tself.log(1,\"GAPPA\",duration,gapDur,splitBridge,self.maximumBridgeGapS*1000)\r\n\t\tlocal blendRessource1= self.Player.getBlendResource()\r\n\t\tif(blendRessource1 == nil ) then\r\n\t\t\treturn\r\n\t\tend\r\n\t\tif splitBridge == true then \r\n\t\t\tblendRessource2= self.Player.getBlendResource()\r\n\t\t\tif(blendRessource2 == nil ) then\r\n\t\t\t\treturn\r\n\t\t\tend\r\n\t\tend\r\n\t\tlocal clip1 = nil\r\n\t\tlocal clip2 = nil\t\t\t\r\n        \r\n\t\tif splitBridge == false then\r\n\t\t\tclip1 = addClipToLayer(layer,gapDur,startFullBlendO,fps,blendRessource1)\r\n\t\telse\r\n\t\t\tclip1 = addClipToLayer(layer,gapDur,startFullBlendO,fps,blendRessource1)\r\n\t\t\tclip2 = addClipToLayer(layer,gapDur,startFullBlendO+duration,fps,blendRessource2)\r\n\t\tend\r\n\t\treturn clip1,clip2\r\n\tend\r\nend\r\n\r\nlocal createBlendClipTransition = function (layer, resource,offsetPlayable,durationPlayable,isIn,fps)\r\n\t--if self.transitionMode == \"Cut\" then return end\r\n\tif layer ~= nil and layer.getHandleInt() ~= 0 then\r\n\t\t\r\n\t\tlocal blendRessource1\r\n\t\tlocal playmode1\r\n\t\tlocal centerMedia1\r\n\t\tlocal blendRessource2\r\n\t\tlocal playmode2\r\n\t\tlocal centerMedia2\t\r\n\t\tlocal gapDur = duration\r\n\t\tlocal splitBridge = false\r\n\t\t if(duration > 10 and duration > self.maximumBridgeGapS*1000) then\r\n\t\t\tsplitBridge = true\r\n\t\t\tgapDur = 0\r\n\t\tend\r\n\t--\tself.log(1,\"GAPPA\",duration,gapDur,splitBridge,self.maximumBridgeGapS*1000)\r\n\t\tlocal blendRessource1= self.Player.getBlendResource()\r\n\t\tif(blendRessource1 == nil ) then\r\n\t\t\treturn\r\n\t\tend\r\n\t\tif splitBridge == true then \r\n\t\t\tblendRessource2= self.Player.getBlendResource()\r\n\t\t\tif(blendRessource2 == nil ) then\r\n\t\t\t\treturn\r\n\t\t\tend\r\n\t\tend\r\n\t\tlocal clip1 = nil\r\n\t\tlocal clip2 = nil\t\t\t\r\n        clip1 = addClipToLayer(layer,gapDur,startFullBlendO,fps,blendRessource1)\r\n\t\treturn clip1,clip2\r\n\tend\r\nend\r\n--------------------------------------------------------------------------------------------------\r\n--------------------------------------------------------------------------------------------------\r\n--------------------------------------------------------------------------------------------------\r\nlocal tl1 = self.TimelineMain();\r\nlocal fps = tl1.getFps()\r\nlocal layer = Pixera.Timelines.Layer.getInst(tl1.getName() .. \".\" .. self.layerPlayName)\r\nif layer == nil or layer.getHandleInt() == 0 then\r\n\treturn\r\nend\r\nlocal layerBlend = Pixera.Timelines.Layer.getInst(tl1.getName() .. \".\" .. self.layerBlendName)\r\nif layerBlend == nil or layerBlend.getHandleInt() == 0 then\r\n\treturn\r\nend\r\n\r\n\r\nlocal objectsInList = #self.playingstatus.scheduleData[1].values\r\nif objectsInList == 0 then\r\n\tself.Player.cleanTimeline(1,\"build 24h no objects\");\r\n\r\n\treturn\r\nend\r\nlocal currentTime = pixc.getRoot().Utils.Timer.now();\r\nlocal currentTimeUtc = pixc.getRoot().Utils.Timer.toStringUtc(currentTime);\r\nif mode == \"new\" then \r\n\tmode = \"updateFromIndex\" \r\n\tindexTlFirstDiff = 1\r\n\tindexScheduleFirstDiff = 1\r\nend\r\n\r\n\r\nif mode == \"updateFromIndex\" then\r\n\t--local startPosTL = indexFirstTL + indexFirstDiff\r\n\t-- Remove Wrong Element in the future\r\n\tself.Player.run24Timeline()\r\n\tlocal nrCurrentTimelineObjects = #self.timelineStatus.objects\r\n\r\n\t--pixc.log(\"RM\",nrCurrentTimelineObjects ,indexTlFirstDiff)\r\n\tremoveTimelineDataUntilIndexFromEnd(indexTlFirstDiff)\r\n\tnrCurrentTimelineObjects = #self.timelineStatus.objects\r\n\t--pixc.log(\"RM3\",nrCurrentTimelineObjects)\r\n\tlocal insertPos = nrCurrentTimelineObjects +1\r\n\tlocal pauseCounter = 20\r\n\tlocal isFirst = true\r\n\tfor k = indexScheduleFirstDiff,objectsInList, 1 do\r\n\t\tpauseCounter = pauseCounter - 1\r\n\t\tif pauseCounter < 1 then\r\n\t\t\tself.Helper.pauseTimelineUpdates()\r\n\t\t\tpauseCounter = 20\r\n\t\tend\r\n\t\tif isFirst == true then\r\n\t\t\tlocal infoObjectLastExisting = self.timelineStatus.objects[insertPos-1]\r\n\t\t\tlocal scheduleEntryLastExisting = self.playingstatus.scheduleData[1].values[indexScheduleFirstDiff-1]\r\n\t\t\tif(scheduleEntryLastExisting ~= nil and infoObjectLastExisting ~= nil) then\r\n\t\t\t\tif infoObjectLastExisting.clips._blend == nil then\r\n\t\t\t\t\tlocal overblendingMs = nil\r\n\t\t\t\t\tlocal vN = self.playingstatus.scheduleData[1].values[k]\r\n\t\t\t\t\tif vN ~= nil then\r\n\t\t\t\t\t\toverblendingMs = pixc.getRoot().Utils.Timer.timeStringDiff(scheduleEntryLastExisting.endTime,vN.startTime,\"ms\") \r\n\t\t\t\t\tend\r\n\t\t\t\t\tif(overblendingMs >10) then\r\n\t\t\t\t\t\tif (self.fadeMediaIfOverlapping == false) then\r\n\t\t\t\t\t\t\tblendWithRessource = true\r\n\t\t\t\t\t\t\toverblendingMs = 0\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tblendWithRessource = false\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tblendWithRessource = true\r\n\t\t\t\t\t\toverblendingMs = overblendingMs *-1\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\tif(overblendingMs == nil) then overblendingMs = 0 end\r\n\t\t\t\tif blendWithRessource == true then\r\n\t\t\t\t\tlocal t, o, nextCommand\r\n\t\t\t\t\tlocal typ, objectName, command = self.Player.parseCommand(scheduleEntryLastExisting.command)\r\n\t\t\t\t\tif self.transitionMode == \"Expert\" then\r\n\t\t\t\t\t\tlocal nextCommand = nil\r\n\t\t\t\t\t\tif vN ~= nil then\r\n\t\t\t\t\t\t\tt, o, nextCommand = self.Player.parseCommand(vN.command)\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\tblendClip1 = self.Hooks.customTransition(true,command,nextCommand,tl1,scheduleEntryLastExisting.endTime,overblendingMs)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tif command.templatePath ~= nil and self.transitionTemplates[command.templatePath._id] == true then\r\n\t\t\t\t\t\t\t-- skip blend media, because Composition handles the transitions\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tlocal startOffsetMs = self.Helper.getOffsetFromTodaysMidnightMs(scheduleEntryLastExisting.startTime)\r\n\t\t\t\t\t\t\tlocal duration = Utils.Timer.timeStringDiff(scheduleEntryLastExisting.endTime, scheduleEntryLastExisting.startTime,\"ms\") \r\n\t\t\t\t\t\t\tblendClip1,blendClip2 = createBlendClip(layerBlend,startOffsetMs+duration+self.tzOffset*1000,overblendingMs,fps)\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\tend\r\n\t\t\t\t\tinfoObjectLastExisting.clips._blend = blendClip1\r\n\t\t\t\t\tinfoObjectLastExisting.clipsSplit._blend = blendClip2\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\tisFirst= false\r\n\t\tend\r\n\t\tlocal infoObject = {}\r\n\t\tinfoObject.clips = {}\r\n\t\tinfoObject.clipsSplit = {}\r\n\t\tlocal blendWithRessource = false;\r\n\t\t--limitCounter = limitCounter + 1\r\n\t\t--self.Helper.logAsJson(\"TLS\",self.timelineStatus)\r\n\t\t\r\n\t\tlocal v = self.playingstatus.scheduleData[1].values[k]\r\n\t\tlocal typ, objectName, command = self.Player.parseCommand(v.command)\r\n\t\tinfoObject._id = v._id;\r\n\t\tlocal startOffsetMs = self.Helper.getOffsetFromTodaysMidnightMs(v.startTime)\r\n\t\tlocal startInSecound = Utils.Timer.timeStringDiff(v.startTime,currentTimeUtc,\"s\") \r\n\t\tlocal endInSecound = startInSecound+(v.duration/1000)\r\n\t\t--pixc.log(\"dfdf\",k,startInSecound,endInSecound, v._id)\r\n\t\t\r\n\t\tlocal vNext = nil\r\n\t\tlocal overblendingMs = nil\r\n\t\tif( k < objectsInList ) then\r\n\t\t\tvNext = self.playingstatus.scheduleData[1].values[k+1]\r\n\t\t\tif(vNext ~= nil) then\r\n\t\t\t\toverblendingMs = Utils.Timer.timeStringDiff(v.endTime,vNext.startTime,\"ms\") \r\n\t\t\tend\r\n\t\t\tif(overblendingMs >10) then\r\n                if (self.fadeMediaIfOverlapping == false) then\r\n                    blendWithRessource = true\r\n\t\t\t\t    overblendingMs = 0\r\n                    v.endTime = vNext.startTime;\r\n                else\r\n\t\t\t\t    blendWithRessource = false\r\n                end\r\n\t\t\telse\r\n\t\t\t\tblendWithRessource = true\r\n\t\t\t\toverblendingMs = overblendingMs *-1\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tvNext =  self.playingstatus.scheduleData.vNext;\r\n\t\tend\r\n\t\tif(overblendingMs == nil) then overblendingMs = 0 end\r\n\r\n\r\n\t\tif(startInSecound < ((20*60)- self.removeMinDurationAfterEnd)*60 and endInSecound > 0) then\t\r\n\t\t\tlocal added = false;\t\r\n\t\t\tinfoObject.offset = startOffsetMs\r\n\t\t\tinfoObject.startTimeUnix = v.startTimeUnix\r\n\t\t\tinfoObject.endTimeUnix = v.endTimeUnix\r\n\r\n\t\t\tlocal duration = Utils.Timer.timeStringDiff(v.endTime, v.startTime,\"ms\") \r\n\r\n\t\t\tlocal blendClip1\r\n\t\t\tlocal blendClip2\r\n\r\n\t\t\tif blendWithRessource == true then\r\n\t\t\t\tlocal t, o, nextCommand\r\n\t\t\t\tif self.transitionMode == \"Expert\" then\r\n\t\t\t\t\tlocal nextCommand = nil\r\n\t\t\t\t\tif vNext ~= nil then\r\n\t\t\t\t\t\t  t, o, nextCommand = self.Player.parseCommand(vNext.command)\r\n\t\t\t\t\tend\r\n\t\t\t\t\tblendClip1 = self.Hooks.customTransition(true,command,nextCommand,tl1,endTime,overblendingMs)\r\n\t\t\t\telse\r\n\t\t\t\t\tif command.templatePath ~= nil and self.transitionTemplates[command.templatePath._id] == true then\r\n\t\t\t\t\t\t-- skip blend media, because Composition handles the transitions\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tblendClip1,blendClip2 = createBlendClip(layerBlend,startOffsetMs+duration+self.tzOffset*1000,overblendingMs,fps)\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\tpixc.log(\"blend\",objectName,blendClip1,blendClip2)\r\n\t\t\t\tinfoObject.clips._blend = blendClip1\r\n\t\t\t\tinfoObject.clipsSplit._blend = blendClip2\r\n\t\t\tend\r\n\r\n\r\n\t\t\tlocal duration = Utils.Timer.timeStringDiff(v.endTime, v.startTime,\"ms\") \r\n\r\n\t\t\tif typ == \"composition\" then\r\n\t\t\t\tlocal infoBefore = self.timelineStatus.objects[insertPos-1]\t\t\t\r\n\t\t\t\tif( command ~= nil and command.data ~= nil) then\r\n\t\t\t\t\tif command.templatePath ~= nil and self.transitionTemplates[command.templatePath._id] == true then\r\n\r\n\t\t\t\t\t\tfor a,b in pairs(command.data) do\r\n\t\t\t\t\t\t\tlocal typ,nr,uid = self.Composition.helper.parseId(a)\r\n\t\t\t\t\t\t\tif(typ == \"med\") then\r\n\t\t\t\t\t\t\t\tlocal resource = self.ContentHandling.getHandleFormMedia(\"video\",b.objectName) \r\n\t\t\t\t\t\t\t\tlocal layer, info = self.Composition.getLayerId(a)\r\n\t\t\t\t\t\t\t\tif(layer~= nil and resource ~= nil) then\r\n\t\t\t\t\t\t\t\t\tlocal r =  self.addPlayableToLayer(tl1,layer,resource,duration,fps,startOffsetMs,infoObject)\r\n\t\t\t\t\t\t\t\t\tif( r == true) then added = true end\r\n\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\tif typ == \"tri\" then\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tlocal resource = self.ContentHandling.getHandleFormMedia(\"video\",b.objectName) \r\n\t\t\t\t\t\t\t\tlocal layer, info = self.Composition.getLayerId(a) \r\n\t\t\t\t\t\t\t\tlocal collision = command.data[info.transitionCombo];\r\n\t\t\t\t\t\t\t\tif infoBefore ~= nil and infoBefore.clipsSplit[\"_blend\"] ~= nil then\r\n\t\t\t\t\t\t\t\t\t\tinfoBefore.clipsSplit[\"_blend\"].removeThis();\r\n\t\t\t\t\t\t\t\t\t\tinfoBefore.clipsSplit[\"_blend\"] = nil\r\n\t\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\tif infoBefore ~= nil and infoBefore.clips[\"_blend\"] ~= nil then\r\n\t\t\t\t\t\t\t\t\t\tinfoBefore.clips[\"_blend\"].removeThis();\r\n\t\t\t\t\t\t\t\t\t\tinfoBefore.clips[\"_blend\"] = nil\r\n\t\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\tif collision == \"Force In\" then\r\n\t\t\t\t\t\t\t\t\tlocal r =  self.addPlayableTransitionToLayer (tl1,layer, resource,startOffsetMs,duration,true,fps,infoObject)\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\r\n\r\n\r\n\t\t\t\t\t\t\t\t\tif infoBefore ~= nil and infoBefore.clipsSplit[\"___transitionOut\"] ~= nil then\r\n\t\t\t\t\t\t\t\t\t\tinfoBefore.clipsSplit[\"___transitionOut\"].removeThis();\r\n\t\t\t\t\t\t\t\t\t\tinfoBefore.clipsSplit[\"___transitionOut\"] = nil\r\n\t\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\tif infoBefore ~= nil and infoBefore.clips[\"___transitionOut\"] ~= nil then\r\n\t\t\t\t\t\t\t\t\t\tinfoBefore.clips[\"___transitionOut\"].removeThis();\r\n\t\t\t\t\t\t\t\t\t\tinfoBefore.clips[\"___transitionOut\"] = nil\r\n\t\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif infoBefore == nil or infoBefore.clips[\"___transitionOut\"] == nil then\r\n\t\t\t\t\t\t\t\t\t\tlocal r =  self.addPlayableTransitionToLayer (tl1,layer, resource,startOffsetMs,duration,true,fps,infoObject)\r\n\t\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\tif typ == \"tro\" then\r\n\t\t\t\t\t\t\t\tlocal resource = self.ContentHandling.getHandleFormMedia(\"video\",b.objectName) \r\n\t\t\t\t\t\t\t\tlocal layer, info = self.Composition.getLayerId(a) \r\n\t\t\t\t\t\t\t\tlocal collision = command.data[info.transitionCombo];\r\n\t\t\t\t\t\t\t\tif collision == \"Force In\" then\r\n\r\n\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\tlocal r =  self.addPlayableTransitionToLayer (tl1,layer, resource,startOffsetMs,duration,false,fps,infoObject)\r\n\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\tif typ == \"trc\" then\r\n\r\n\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\tif typ == \"lid\" then\r\n\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\tif typ == \"lis\" then\r\n\t\t\t\t\t\t\t\tlocal liveInputnamne = b;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tlocal resource = self.ContentHandling.getLiveInput(liveInputnamne);\r\n\t\t\t\t\t\t\t\t--pixc.log(\"Live Resource\",liveInputnamne, resource)\r\n\t\t\t\t\t\t\t\tlocal layer, info = self.Composition.getLayerId(a)\r\n\t\t\t\t\t\t\t\tlocal durationLive = command.data[info.liveDurationId];\r\n\t\t\t\t\t\t\t\tif(durationLive < 1) then\r\n\t\t\t\t\t\t\t\t\tdurationLive = duration\r\n\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t\tif(layer~= nil and resource ~= nil) then\r\n\t\t\t\t\t\t\t\t\tlocal r =  self.addPlayableToLayer(tl1,layer,resource,durationLive,fps,startOffsetMs,infoObject)\r\n\t\t\t\t\t\t\t\t\tif( r == true) then added = true end\r\n\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor k,v in pairs(command.data) do\r\n\t\t\t\t\t\t\tif(type(v) == 'table' and v.objectName ~= nil) then\r\n\t\t\t\t\t\t\t\tlocal resource = self.ContentHandling.getHandleFormMedia(\"video\",v.objectName) \r\n\t\t\t\t\t\t\t\tlocal layer, info = self.Composition.getLayerId(k)\r\n\r\n\t\t\t\t\t\t\t\tif(layer~= nil and resource ~= nil) then\r\n\t\t\t\t\t\t\t\t\tlocal r =  self.addPlayableToLayer(tl1,layer,resource,duration,fps,startOffsetMs,infoObject)\r\n\t\t\t\t\t\t\t\t\tif( r == true) then added = true end\r\n\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\tend\r\n\t\t\t\t\t\r\n\t\t\t\tend\r\n\t\t\telse\r\n\t\t\t\tlocal resource = self.ContentHandling.getHandleFormMedia(\"video\",objectName) \r\n\t\t\t\tlocal r =  self.addPlayableToLayer(tl1,layer,resource,duration,fps,startOffsetMs,infoObject)\r\n\t\t\t\tif( r == true) then added = true end\r\n\t\t\tend\r\n\t\t\tif(added == true) then\r\n\t\t\t\tself.timelineStatus.objects[insertPos] = infoObject\r\n\t\t\t\tinsertPos = insertPos +1\r\n\t\t\telse\r\n\t\t\t\tif(infoObject.clips._blend ~= nil) then\r\n\t\t\t\t\tinfoObject.clips._blend.removeThis()\r\n\t\t\t\tend\r\n\t\t\t\tif(infoObject.clipsSplit._blend ~= nil) then\r\n\t\t\t\t\tinfoObject.clipsSplit._blend.removeThis()\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\t\r\n\tend\r\n\tself.Player.dumpTimeLineData()\r\n\treturn\r\nend\r\nif mode == \"update\" then\r\n\tself.Player.buildTimeline24(\"updateChanged\")\r\n\treturn\r\nend\r\n\r\nif mode == \"updateChanged\" then\r\n\tif #self.timelineStatus.objects  == 0 then\r\n\t\tself.Player.buildTimeline24(\"new\")\r\n\t\treturn\r\n\tend\r\n\tlocal indexFirstTL =  nil\r\n\r\n\t--pixc.log(\"TLCount B efore remove Old\",#self.timelineStatus.objects)\r\n\tremoveOldTimeLineData()\r\n\t--pixc.log(\"TLCount RemovedOld\",#self.timelineStatus.objects)\r\n\r\n\tlocal firstTlMatch = nil\r\n\tlocal firstScheduleMatch = nil\r\n\tlocal tlC = 1\r\n\tfor k,v in ipairs(self.timelineStatus.objects) do\r\n\t\tlocal schedC = 1\r\n\t\tfor m,n in ipairs(self.playingstatus.scheduleData[1].values) do\r\n\t\t\tif v._id == n._id then\r\n\t\t\t\tfirstTlMatch = tlC\r\n\t\t\t\tfirstScheduleMatch = schedC\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\t\tschedC = schedC + 1;\r\n\t\tend\r\n\t\tif(firstTlMatch ~= nil) then\r\n\t\t\tbreak\r\n\t\tend\r\n\t\ttlC = tlC + 1\r\n\tend\r\n\t-- no match found -> rebuild\r\n\tif firstTlMatch == nil then\r\n\t\tself.Player.buildTimeline24(\"new\")\r\n\t\treturn\r\n\tend\r\n\tlocal counterTL = firstTlMatch;\r\n\tlocal counterScheduleData = firstScheduleMatch\r\n\tfor counterScheduleData = firstScheduleMatch, #self.playingstatus.scheduleData[1].values,1 do\r\n\t\t--pixc.log(\"counterScheduleData\",counterScheduleData)\r\n\t\tif self.timelineStatus.objects[counterTL] == nil then\r\n\t\t\tself.Player.buildTimeline24(\"updateFromIndex\",firstTlMatch,firstScheduleMatch,counterTL,counterScheduleData)\r\n\t\t\treturn\r\n\t\tend\r\n\t\tif self.timelineStatus.objects[counterTL]._id ~= self.playingstatus.scheduleData[1].values[counterScheduleData]._id then\r\n\t\t\tself.Player.buildTimeline24(\"updateFromIndex\",firstTlMatch,firstScheduleMatch,counterTL,counterScheduleData)\r\n\t\t\treturn\r\n\t\tend\r\n\t\tcounterTL = counterTL + 1\r\n\tend\r\n\t--pixc.log(\"CurrentTimeline to long -> remove\")\r\n\tremoveTimelineDataUntilIndexFromEnd(counterTL)\r\n\treturn\r\nend\r\n",
     "kind": "func",
     "name": "buildTimeline24",
     "params": [
      {
       "name": "mode",
       "type": ""
      },
      {
       "name": "indexFirstTlMatch",
       "type": ""
      },
      {
       "name": "indexFirstScheduleMatch",
       "type": ""
      },
      {
       "name": "indexTlFirstDiff",
       "type": ""
      },
      {
       "name": "indexScheduleFirstDiff",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Player.buildTimeline24"
    },
    {
     "body": "if true then return end\r\n\r\nlocal obj = {}\r\nfunction table.shallow_copy(t)\r\n  local t2 = {}\r\n  for k,v in pairs(t) do\r\n    t2[k] = v\r\n  end\r\n  return t2\r\nend\r\nfor k,v in pairs(self.timelineStatus.objects) do\r\n\t\tlocal o = {}\r\n\t\r\n\to = table.shallow_copy(v);\r\n\tfor a,b in pairs(v.clips) do\r\n\t\tif b ~= nil then\r\n\t\t\tlocal l = b.getAssignedResource()\r\n\t\t\tif(l ~= nil) then\r\n\t\t\t\to.clips[a] = l.getName()\r\n\t\t\telse \r\n\t\t\t\to.clips[a] = \"nil\"\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\tfor a,b in pairs(v.clipsSplit) do\r\n\t\tif b ~= nil then\r\n\t\t\tlocal l = b.getAssignedResource()\r\n\t\t\tif(l ~= nil) then\r\n\t\t\t\to.clips[a] = l.getName()\r\n\t\t\telse \r\n\t\t\t\to.clips[a] = \"nil\"\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\to.k = k\r\n\tobj[k] = o\r\nend\r\n\r\nself.Helper.dumpToFile(obj,\"D:/isaac/\"..self()..\".json\")\r\n",
     "kind": "func",
     "name": "dumpTimeLineData",
     "path": "ISAACPlayer24H.Player.dumpTimeLineData"
    },
    {
     "body": "self.calcualateLoopReqirement = function(position,duration)\r\n\tif (position + duration) <= self.loopCue24Pos or position > self.loopCue24Pos  then\r\n\t\treturn false\r\n\tend\r\n\tlocal newDur1 = self.loopCue24Pos - position;\r\n\tlocal newDur2 = duration - newDur1\r\n\tlocal inPoint = duration - newDur2\r\n\treturn true, newDur1,newDur2, inPoint\r\nend\r\nself.calculateLoopPosition = function (position)\r\n\tif (position) > self.loopCue24Pos then\r\n\t\treturn position - self.loopCue24Pos\r\n\tend\r\n\treturn position\r\nend\r\n\r\n\r\nself.addPlayableToLayer = function (tl1,layer,resource,duration,fps,startOffsetMs,infoObject)\r\n\tlocal layerName = layer.getName()\r\n\tlocal dur = duration*fps/1000\t\r\n\tlocal t = 0\r\n\tif startOffsetMs ~= nil then\r\n\t\tt = ((startOffsetMs/1000)+self.tzOffset)*fps;\r\n\tend\r\n\tlocal req,dur1,dur2,inp = self.calcualateLoopReqirement(t,dur)\r\n\tlocal added = false;\r\n\tt = self.calculateLoopPosition(t)\r\n\tlocal clip = layer.createClipAtTime(t)\r\n\tif( infoObject ~= nil ) then\r\n\t\tinfoObject.offsetAbs = t\r\n\t\tinfoObject.dur = dur\r\n\tend\r\n\t--pixc.log(\"Create Clip\",resource.getName())\r\n\tif clip ~= nil then\t\t\t\t\t\r\n\t\tdur = math.ceil(dur)\t\t\t\t\t\t\t\t\t\t\t\t \r\n\t\tclip.setDuration(dur)\r\n\t\tclip.setTime(t)\r\n\t\tclip.setPlayMode(5) -- once\t\r\n\t\tclip.assignResource(resource.getId())\t\r\n\t\tif( infoObject ~= nil ) then\r\n\t\t\tinfoObject.clips[layerName] = clip;\t\t\r\n\t\tend\r\n\t\tlocal cuesBefore = tl1.getCues();\r\n\t\tclip.setDuration(dur)\r\n\t\tself.Hooks.postPlayableAdded(command,tl1,layer,t,dur)\r\n\t\tif(req) then\r\n\t\t\tif( infoObject ~= nil ) then\r\n\t\t\t\tinfoObject.offsetAbs = t\r\n\t\t\t\tinfoObject.dur2 = dur2\r\n\t\t\tend\r\n\t\t\tdur = math.ceil(dur1)\t\t\t\t\t\t\t\t\t\t\t\t \r\n\t\t\tclip.setDuration(dur)\r\n\t\t\tclip = layer.createClipAtTime(0)\r\n\t\t\tif clip ~= nil then\t\t\t\t\t\r\n\t\t\t\tdur = math.ceil(dur2)\t\t\t\t\t\t\t\t\t\t\t\t \r\n\t\t\t\tclip.setDuration(dur)\r\n\t\t\t\t--clip.setTime(0)\r\n\t\t\t\tclip.setPlayMode(5) -- once\t\r\n\t\t\t\tif( infoObject ~= nil ) then\r\n\t\t\t\t\tinfoObject.clipsSplit[layerName] = clip;\r\n\t\t\t\t\tinfoObject.dur2 = dur\r\n\t\t\t\t\tinfoObject.inpoint = inp\r\n\t\t\t\tend\r\n\t\t\t\tlocal cuesBefore = tl1.getCues();\r\n\t\t\t\tclip.assignResource(resource.getId())\t\r\n\t\t\t\tclip.setDuration(dur)\r\n\t\t\t\tclip.setInpoint(inp)\r\n\t\t\t\t\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\tself.Hooks.postPlayableAdded(command,tl1,layer,t,dur)\r\n\t\t\t\r\n\t\tend\r\n\t\treturn true\r\n\tend\r\n\treturn false\r\nend\r\n\r\n\r\nself.addPlayableTransitionToLayer = function (tl1,layer, resource,offsetPlayable,durationPlayable,isIn,fps,infoObject)\r\n\tlocal clipName = nil\r\n\tif(resource == nil) then return end\r\n\r\n\tlocal resourceDuration = resource.getDuration();\r\n\tlocal startOffsetMs = offsetPlayable;\r\n\tif (isIn == false) then\r\n\t\tstartOffsetMs = startOffsetMs + durationPlayable -(resourceDuration*1000/2);\r\n\t\tclipName = \"___transitionOut\"\r\n\telse\r\n\t\tstartOffsetMs = startOffsetMs -(resourceDuration*1000/2);\r\n\t\tclipName = \"___transitionIn\"\r\n\tend\r\n\r\n\tlocal dur = resource.getDuration()*fps\r\n\tlocal t = 0\r\n\tif startOffsetMs ~= nil then\r\n\t\tt = ((startOffsetMs/1000)+self.tzOffset)*fps;\r\n\tend\r\n\r\n\r\n\tlocal req,dur1,dur2,inp = self.calcualateLoopReqirement(t,dur)\r\n\tlocal added = false;\r\n\tt = self.calculateLoopPosition(t)\r\n\tlocal clip = layer.createClipAtTime(t)\r\n\tif( infoObject ~= nil ) then\r\n\t\tinfoObject.offsetAbs = t\r\n\t\tinfoObject.dur = dur\r\n\tend\r\n\t--pixc.log(\"Create Clip\",resource.getName())\r\n\tif clip ~= nil then\t\t\t\t\t\r\n\t\tdur = math.ceil(dur)\t\t\t\t\t\t\t\t\t\t\t\t \r\n\t\tclip.setDuration(dur)\r\n\t\tclip.setTime(t)\r\n\t\tclip.setPlayMode(5) -- once\t\r\n\t\tclip.assignResource(resource.getId())\t\r\n\t\tif( infoObject ~= nil ) then\r\n\t\t\tinfoObject.clips[clipName] = clip;\t\t\r\n\t\tend\r\n\t\tlocal cuesBefore = tl1.getCues();\r\n\t\tclip.setDuration(dur)\r\n\t\tif(req) then\r\n\t\t\tif( infoObject ~= nil ) then\r\n\t\t\t\tinfoObject.offsetAbs = t\r\n\t\t\t\tinfoObject.dur2 = dur2\r\n\t\t\tend\r\n\t\t\tdur = math.ceil(dur1)\t\t\t\t\t\t\t\t\t\t\t\t \r\n\t\t\tclip.setDuration(dur)\r\n\t\t\tclip = layer.createClipAtTime(0)\r\n\t\t\tif clip ~= nil then\t\t\t\t\t\r\n\t\t\t\tdur = math.ceil(dur2)\t\t\t\t\t\t\t\t\t\t\t\t \r\n\t\t\t\tclip.setDuration(dur)\r\n\t\t\t\t--clip.setTime(0)\r\n\t\t\t\tclip.setPlayMode(5) -- once\t\r\n\t\t\t\tif( infoObject ~= nil ) then\r\n\t\t\t\t\tinfoObject.clipsSplit[clipName] = clip;\r\n\t\t\t\t\tinfoObject.dur2 = dur\r\n\t\t\t\t\tinfoObject.inpoint = inp\r\n\t\t\t\tend\r\n\t\t\t\tlocal cuesBefore = tl1.getCues();\r\n\t\t\t\tclip.assignResource(resource.getId())\t\r\n\t\t\t\tclip.setDuration(dur)\r\n\t\t\t\tclip.setInpoint(inp)\t\t\t\r\n\t\t\tend\r\n\t\tend\r\n\t\treturn true\r\n\tend\r\n\treturn false\r\nend\r\nif self.Player.parseCommand == nil then\r\n\tself.Player.parseCommand = function(command)\r\n\t\tlocal obj ={}\r\n\t\tlocal command = self.jsonlib.decode(command)\r\n\t\tif(command == nil) then \r\n\t\t\tself.log(1,\"Error parising command\")\r\n\t\t\treturn\r\n\t\tend\r\n\r\n\t\t--local objectName = command.data.video.object\r\n\t\tlocal objectName = command.object\r\n\t\t--if(command.templatePath == nil or command.templatePath.name == nil or command.templatePath.name ~= '_defaultVideo') then\r\n\t\t--\treturn \"custom\", \"\", command;\r\n\t\t--end\r\n\t\tif command.templatePath ~= nil and command.templatePath.name ~= nil then\r\n\t\t\tif command.templatePath.name  == \"_defaultVideo\" then\r\n\t\t\t\tif command.data.video ~= nil then \r\n\t\t\t\t\treturn \"video\",command.data.video.object,command;\r\n\t\t\t\telse\r\n\t\t\t\t\tif command.data.audio ~= nil then \r\n\t\t\t\t\t\treturn \"video\",command.data.audio.object,command;\r\n\t\t\t\t\tend\r\n\t\t\t\tend\t\t\t\r\n\t\t\tend\r\n\t\t\treturn \"composition\",\" \",command,obj\r\n\t\tend\r\n\r\n\t\tif(command.data ~= nil and command.data.video ~= nil) then\r\n\t\t\treturn \"video\",command.data.video.object,command;\r\n\t\tend\r\n\t\t\r\n\t\tif(command.data ~= nil and command.data.audio ~= nil) then\r\n\t\t\treturn \"video\",command.data.audio.object,command;\r\n\t\tend\r\n\tend\r\n\t--pixc.log(\"parseCommand registered\")\r\nend\r\n",
     "kind": "func",
     "name": "registerPlayerFunctions",
     "path": "ISAACPlayer24H.Player.registerPlayerFunctions"
    },
    {
     "body": "local tl1 = nil\r\nlocal tl2 = nil\r\n\r\nfunction filterstring(s, filter)\r\n    local result = ''\r\n    for i = 0, #s do\r\n        local c = string.sub(s, i, i)\r\n        if filter(c) then\r\n            result = result .. c\r\n        end\r\n    end\r\n    return result\r\nend\r\nfunction filterstringnum(s, min, max)\r\n    local filter = function(c)\r\n        local b = string.byte(c)\r\n        if b == nil then\r\n            return false\r\n        end\r\n        return b > min and b < max\r\n    end\r\n    return filterstring(s, filter)\r\nend\r\nfunction rmSpecialChar(s)\r\n    return filterstringnum(s, 0, 128)\r\nend\r\n\r\n--local CurrentTimelineIndex = 1\r\n\r\ntl1 = self.TimelineMain()\r\nlocal fps = tl1.getFps()\r\nlocal layer = self.Pixera().Timelines.Layer.getInst(tl1.getName() .. \".\"..self.layerPlayName)\r\nif layer ~= nil then\r\n\tlocal currentTime = tl1.getCurrentTime()\r\n\tif currentTime >= self.InstantPlayPos then\r\n\t\tlocal clip = layer.getClipCurrent(0)\r\n\t\tif clip == nil then\r\n\t\t\tself.UI.PlayInstantModeFile(\"\",true)\r\n\t\t\tself.UI.PlayInstantMediaTime(\"\",true)\r\n\t\t\tself.UI.PlayInstantModeStatus(0,true);\r\n\t\telse\r\n\t\t\tlocal res = clip.getAssignedResource();\r\n\t\t\tif(res == nil) then\r\n\t\t\t\tself.UI.PlayInstantModeFile(\"\",true)\r\n\t\t\t\tself.UI.PlayInstantModeStatus(0,true);\r\n\t\t\t\tself.UI.PlayInstantMediaTime(0,true)\r\n\t\t\telse\r\n\t\t\t\tlocal t = currentTime\r\n\t\t\t\tlocal dur = clip.getDuration()\r\n\t\t\t\tlocal tr = clip.getTime();\r\n\t\t\t\tlocal playedTime = t - tr;\r\n\t\t\t\tlocal a = playedTime/dur*100;\r\n\t\t\t\tself.UI.PlayInstantModeFile(rmSpecialChar(res.getName()),true)\r\n\t\t\t\tself.UI.PlayInstantModeStatus(a,true);\r\n\t\t\t\tself.UI.PlayInstantMediaTime(self.helper.framesToHms(playedTime,fps),true)\r\n\t\t\tend\r\n\t\tend\r\n\t\tself.UI.currentMedia(\"\",true)\r\n\t\tself.UI.currentMediaStatus(0,true);\r\n\t\tself.UI.CurrentMediaTime(\"\",true)\r\n\telse\r\n\t\tlocal clip = layer.getClipCurrent(0)\r\n\t\tif clip == nil then\r\n\t\t\tself.UI.currentMedia(\"\",true)\r\n\t\t\tself.UI.currentMediaStatus(0,true);\r\n\t\t\tself.UI.CurrentMediaTime(\"\",true)\r\n\t\telse\r\n\t\t\tlocal res = clip.getAssignedResource();\r\n\t\t\tif(res == nil) then\r\n\t\t\t\tself.UI.currentMedia(\"\",true)\r\n\t\t\t\tself.UI.currentMediaStatus(0,true);\r\n\t\t\telse\r\n\t\t\t\tlocal t = currentTime\r\n\t\t\t\tlocal dur = clip.getDuration()\r\n\t\t\t\tlocal tr = clip.getTime();\r\n\t\t\t\tlocal playedTime = t - tr;\r\n\t\t\t\tlocal a = playedTime/dur*100;\r\n\t\t\t\tself.UI.currentMedia(rmSpecialChar(res.getName()),true)\r\n\t\t\t\tself.UI.currentMediaStatus(a,true);\r\n\t\t\t\tself.UI.CurrentMediaTime(self.helper.framesToHms(playedTime,fps),true)\r\n\t\t\tend\r\n\t\tend\r\n\t\t\tself.UI.PlayInstantModeFile(\"\",true)\r\n\t\t\tself.UI.PlayInstantMediaTime(\"\",true)\r\n\t\t\tself.UI.PlayInstantModeStatus(0,true);\r\n\tend\r\nend\r\n\r\ntl1 = self.TimelineMain()\r\nlocal layerB = self.Pixera().Timelines.Layer.getInst(tl1.getName() .. \".\"..self.layerBlendName)\r\nif layerB ~= nil then\r\n\tlocal clip = layerB.getClipCurrent(0)\r\n\tif clip == nil then\r\n\t\tself.UI.TransitionMedia(\"\",true)\r\n\t\tself.UI.TransitionStatus(0,true);\r\n\t\tself.UI.TransitionMode(self.transitionMode,true)\r\n\t\tself.UI.TransitionMediaTime(\"\",true)\r\n\telse\r\n\t\t\r\n\t\tlocal res = clip.getAssignedResource();\r\n\t\tif(res == nil ) then\r\n\t\t\tself.UI.TransitionMedia(\"\",true)\r\n\t\t\tself.UI.TransitionStatus(0,true);\r\n\t\t\tself.UI.TransitionMode(self.transitionMode,true)\r\n\t\t\tself.UI.TransitionMediaTime(\"\",true)\r\n\t\telse\r\n\t\t\tlocal t = tl1.getCurrentTime()\r\n\t\t\tlocal dur = clip.getDuration()\r\n\t\t\tlocal tr = clip.getTime();\r\n\t\t\tlocal playedTime = t - tr;\r\n\t\t\tlocal a = playedTime/dur*100;\r\n\t\t\tself.UI.TransitionMedia(rmSpecialChar(res.getName()),true)\r\n\t\t\tself.UI.TransitionStatus(a,true);\r\n\t\t\tself.UI.TransitionMode(self.transitionMode,true)\r\n\t\t\tself.UI.TransitionMediaTime(self.helper.framesToHms(playedTime,fps),true)\r\n\t\tend\r\n\tend\r\nend\r\n\r\nlocal round = function (number, precision)\r\n   local fmtStr = string.format('%%0.%sf',precision)\r\n   number = string.format(fmtStr,number)\r\n   return number\r\nend\r\nlocal liveSystem = self.LiveSystem();\r\nif liveSystem ~= nil then\r\n\tif self.jsonlib == nil then\r\n\t\tself.jsonlib = require \"json\" \r\n\tend\r\n\tlocal l = liveSystem.getPerformanceMonitoringValuesJson()\r\n\t--self.log(1,\"liveSystems\",l)\r\n\tif( l ~= nil and l ~= \"\") then\r\n\t\tlocal j = self.jsonlib.decode(l)\r\n\t\tif j ~= nil then\r\n\t\t\tlocal availableRam = j.AvailablePhysicalMemory / 1024 / 1024 /1024;\r\n\t\t\tlocal totalRam = j.TotalPhysicalMemory / 1024 / 1024/ 1024;\r\n\t\t\tlocal cpuUsage = j.TotalCpu*100;\r\n\t\t\tlocal usedRam = totalRam -availableRam;\r\n\t\t\tlocal ramUsage = (usedRam /totalRam) *100\r\n\r\n\t\t\tlocal ramS = round(usedRam,1) ..\" GB / \"..round(totalRam,1)..\" GB (\"..round(ramUsage,1).. \" %)\";\r\n\t\t\tlocal  cpuS = round(cpuUsage,1)..\" %\";\r\n\t\t\tself.UI.MemoryUsage(ramS,true)\r\n\t\t\tself.UI.CpuUsage(cpuS,true)\r\n\t\tend\r\n\tend\r\nend\r\n\r\nif self.enableInstantPlay == true then\r\n\tself.UI.PlayInstantMode(self.instantPlayStatus);\r\nelse\r\n\tself.UI.PlayInstantMode(\"Disabled\");\r\nend\r\nself.UI.PlayInstantModeFile(self.instantPlayMedia);\r\n",
     "kind": "func",
     "name": "updateUI",
     "path": "ISAACPlayer24H.Player.updateUI"
    }
   ],
   "kind": "ns",
   "name": "Player"
  },
  {
   "elems": [
    {
     "body": "if(self.resourcePathCache == nil) then  self.resourcePathCache = {} end\r\n\r\n\r\nif self.resourcePathCache[subdir] == nil or self.resourcePathCache[subdir].getHandleInt() == 0 then\r\n\tlocal path = \"Media/\"..self.mappedContentFolder\r\n\tif(subdir) then\r\n\t\tpath = path..\"/\"..(subdir)\r\n\tend\r\n\tpath = pixc.getRoot().Utils.Filesystem.normalizePath(path)\r\n\tself.resourcePathCache[subdir] = pixc.getRoot().Pixera.Resources.getResourceFolderWithNamePath(path)\r\n\tif self.resourcePathCache[subdir] == nil or self.resourcePathCache[subdir].getHandleInt() == 0 then\r\n\t\treturn nil\r\n\tend\r\nend\r\nreturn self.resourcePathCache[subdir]\r\n",
     "kind": "func",
     "name": "getFolderResource",
     "params": [
      {
       "name": "subdir",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.getFolderResource"
    },
    {
     "body": "if (type == \"custom\") then\r\n\treturn nil\r\nend\r\n\r\nlocal getR = function (type,name)\r\n\tlocal folder = self.ContentHandling.getFolderResource(type)\r\n\tif folder == nil or folder.getHandleInt() == 0 then\r\n\t\tself.log(1,\" Resourcefolder not found: \"..resFolder)\r\n\t\treturn nil\r\n\tend\r\n\r\n\tlocal resources = folder.getResources();\r\n\r\n\tif resources ~= nil then\r\n\t\tfor k,v in ipairs(resources) do\r\n\t\t--self.log(1,k,v)\r\n\t\t\tlocal nameH = v.getName()\r\n\t\t\t--self.log(1,nameH)\r\n\t\t\tif(nameH == name) then\r\n\t\t\t\t--self.log(1,v)\r\n\t\t\t\treturn v\r\n\t\t\tend\r\n\t\tend \r\n\tend\r\n\treturn nil\r\nend\r\n\r\nlocal r = getR(type,name)\r\nif (r == nil ) then\r\n\tr = getR(\"image\",name)\r\nend\r\nif (r == nil ) then\r\n\tr = getR(\"audio\",name)\r\nend\r\nreturn r\r\n",
     "kind": "func",
     "name": "getHandleFormMedia",
     "params": [
      {
       "name": "type",
       "type": "string"
      },
      {
       "name": "name",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.getHandleFormMedia"
    },
    {
     "body": "local folder = pixc.getRoot().Pixera.Resources.getResourceFolderWithNamePath(\"Media/Live Inputs\")\r\nif folder == nil or folder.getHandleInt() == 0 then\r\n\tself.log(1,\" LiveInput folder not found \")\r\n\treturn nil\r\nend\r\n\r\nlocal resources = folder.getResources();\r\n\r\nif resources ~= nil then\r\n\tfor k,v in ipairs(resources) do\r\n\t--self.log(1,k,v)\r\n\t\tlocal nameH = v.getName()\r\n\t\t--self.log(1,nameH)\r\n\t\tif(nameH == name) then\r\n\t\t\t--self.log(1,v)\r\n\t\t\treturn v\r\n\t\tend\r\n\tend \r\nend\r\nreturn nil",
     "kind": "func",
     "name": "getLiveInput",
     "params": [
      {
       "name": "name",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.getLiveInput"
    },
    {
     "body": "local json = self.jsonlib.decode(data)\r\n--self.log(1,\"status:\",self.jsonlib.encode(json))\r\n\r\nif json ~= nil then\r\n\tif json.id ~= nil then\r\n\t\tif (json.event == \"object_sync_complete\") then\r\n\t\t\t--self.log(1,\"Sync Complete Message\",json.message)\r\n\t\t\tif(json.message == \"Already exists, skipping\") then\r\n\t\t\t\t--self.ContentHandling.setSyncStatus( json.id, \"exists\")\r\n\t\t\t\treturn\r\n\t\t\tend\r\n\t\t\tif(json.message == \"Download Successful\") then\r\n\t\t\t\tself.ContentHandling.setSyncStatus( json.id, \"added\")\r\n\t\t\t\treturn\r\n\t\t\tend\r\n\t\t\tself.ContentHandling.setSyncStatus( json.id, json.message)\r\n\t\tend\t\t\r\n\tend\r\n\tif json.event == \"sync_report\" then\r\n\t\t\tself.log(1,\"Downloader Report: \", json.message)\r\n\tend\r\nend\r\n--self.log(1,\"status:\",self.jsonlib.encode(self.syncStatusData))\r\n",
     "kind": "func",
     "name": "runSyncToolExternal",
     "params": [
      {
       "name": "includeObjects",
       "type": "object"
      },
      {
       "name": "finishedCallback",
       "type": "object"
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.runSyncToolExternal"
    },
    {
     "body": "local obj = \"\";\r\npixc.suppressCallRefs()\r\nif self.ContentHandling.checkRunning() then\r\n\tself.log(1,\"Download already running, ignored\")\r\n\treturn false\r\nend\r\nif type(includeObjects) == 'string' then\r\n\tobj = includeObjects;\r\nelse\r\n\tif type(includeObjects) == 'number' then\r\n\t\tobj = math.tointeger(includeObjects)\r\n\telse\r\n\t\tif type(includeObjects) == 'table' then\r\n\t\t\tfor k,v in ipairs(includeObjects) do\r\n\t\t\t\tobj = obj..v..\",\";\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\n\r\nlocal auxRoot = self().getProperty(\"aux_root\")\r\nlocal file = auxRoot..\"/Apps/isaac_sync_tool.exe\";\r\nlocal param = ' --address '..self.url..' --moduleid '..self.externalIdSchedule..' --path-audio \"'..self.audioPath..'\" --path-video \"'..self.videoPath..'\" --path-image \"'..self.imagePath..'\" --path-other \"'..self.otherPath..'\" --include-object '..obj\r\nif self.udpComPort > 0 then\r\n\tparam = param.. ' --udp-target 127.0.0.1:'..self.udpComPort\r\nend\r\nif self.enableInstantPlay == true then \r\n\tparam = param..\" --include-force-cache\"\r\nend\r\n\r\nif((overrideClean == nil and self.downloaderCleanMode == true) or overrideClean == true) then\r\n\tparam = param..' --clean'\r\nend\r\nlocal execCommand = file..param\r\nself.log(1,\"Running downloader\",execCommand)\r\nself.downloadHandle = pixc.getRoot().Utils.System.spawnProcess(file,param,function(err,a,b) self.log(1,\"Finished downloader\",err,a); self.downloadHandle = nil; if finishedCallback ~= nil then finishedCallback() end; end,self.consoleHideCode,self.consoleLogFile)\r\nreturn true\r\n",
     "kind": "func",
     "name": "runSyncTool",
     "params": [
      {
       "name": "includeObjects",
       "type": "object"
      },
      {
       "name": "finishedCallback",
       "type": "object"
      },
      {
       "name": "overrideClean",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.runSyncTool"
    },
    {
     "body": "local obj = \"\";\r\npixc.suppressCallRefs()\r\nif self.ContentHandling.checkRunning() then\r\n\tself.log(1,\"Download already running -> ignored\")\r\n\treturn false\r\nend\r\nlocal auxRoot = self().getProperty(\"aux_root\")\r\nlocal file = auxRoot..\"/Apps/isaac_sync_tool.exe\";\r\nlocal param = ' --address '..self.url..' --moduleid '..self.externalIdSchedule..' --path-audio \"'..self.audioPath..'\" --path-video \"'..self.videoPath..'\" --path-image \"'..self.imagePath..'\" --path-other \"'..self.otherPath..'\"'\r\nif self.udpComPort > 0 then\r\n\tparam = param.. ' --udp-target 127.0.0.1:'..self.udpComPort\r\nend\r\nif self.enableInstantPlay == true then \r\n\tparam = param..\" --include-force-cache\"\r\nend\r\nif((overrideClean == nil and self.downloaderCleanMode == true) or overrideClean == true) then\r\n\tparam = param..' --clean'\r\nend\r\nlocal execCommand = file..param\r\nself.log(1,\"Running Downloader\")--,execCommand)\r\n\r\nself.downloadHandle = pixc.getRoot().Utils.System.spawnProcess(file,param,function(err,a,b) self.log(1,\"Finished Downloader\",err,a); self.downloadHandle = nil; if finishedCallback ~= nil then finishedCallback() end; end,self.consoleHideCode,self.consoleLogFile)\r\n\r\nreturn true\r\n",
     "kind": "func",
     "name": "runSyncToolSchedule",
     "params": [
      {
       "name": "finishedCallback",
       "type": "object"
      },
      {
       "name": "overrideClean",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.runSyncToolSchedule"
    },
    {
     "body": "local json = self.jsonlib.decode(data)\r\n--self.log(1,\"status:\",self.jsonlib.encode(json))\r\n\r\nif json ~= nil then\r\n\tif json.id ~= nil then\r\n\t\tif (json.event == \"object_sync_complete\") then\r\n\t\t\t--self.log(1,\"Sync Complete Message\",json.message)\r\n\t\t\tif(json.message == \"Already exists, skipping\") then\r\n\t\t\t\t--self.ContentHandling.setSyncStatus( json.id, \"exists\")\r\n\t\t\t\treturn\r\n\t\t\tend\r\n\t\t\tif(json.message == \"Download Successful\") then\r\n\t\t\t\tself.ContentHandling.setSyncStatus( json.id, \"added\")\r\n\t\t\t\treturn\r\n\t\t\tend\r\n\t\t\tself.ContentHandling.setSyncStatus( json.id, json.message)\r\n\t\tend\t\t\r\n\tend\r\n\tif json.event == \"sync_report\" then\r\n\t\t\tself.log(1,\"Downloader Report: \", json.message)\r\n\tend\r\nend\r\n--self.log(1,\"status:\",self.jsonlib.encode(self.syncStatusData))\r\n",
     "kind": "func",
     "name": "handleContentCallbackInfo",
     "params": [
      {
       "name": "data",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.handleContentCallbackInfo"
    },
    {
     "body": "if self.syncStatusData == nil then\r\n\tself.syncStatusData = {}\r\nend\r\n\r\nreturn self.syncStatusData[id]\r\n",
     "kind": "func",
     "name": "setSyncStatus",
     "params": [
      {
       "name": "id",
       "type": "int"
      },
      {
       "name": "status",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.setSyncStatus"
    },
    {
     "body": "local t = optionalType;\r\n--self.log(1,\"CleanMode\",overrideClean)\r\n\r\nlocal  callAddResource = function(folder,path,removeOthers,checkRedundency,overrideClean)\r\n\r\n\tif overrideClean == \"CLEAN_FORCE\" and self.addResourcesFromDirectoryRemoveAssetsMissing ~= true then\r\n\t\tlocal a,b = pcall(folder.addResourcesFromDirectoryRemoveAssets,path,removeOthers,checkRedundency)\r\n\t\tif(a == false) then\r\n\t\t\tself.log(1,\"addResourcesFromDirectoryRemoveAssets failed (May missig API) -> fallback to addResourcesFromDirectory\")\r\n\t\t\tself.addResourcesFromDirectoryRemoveAssetsMissing = true\r\n\t\telse\r\n\t\t\treturn\r\n\t\tend\r\n\tend\r\n\tfolder.addResourcesFromDirectory(path,removeOthers,checkRedundency)\r\nend\r\nif(optionalType == nil or optionalType == \"all\" or type(optionalType) ~= 'string') then\r\n\tt = \"all\"\r\nend\r\nif videoArr == nil and audioArr == nil and imageArr == nil and otherArr == nil then\r\n    if( t == \"all\" or t == \"video\") then\r\n        local folder = self.ContentHandling.getFolderResource(\"video\")\r\n        callAddResource(folder,self.videoPath, true, true,overrideClean)\r\n    end\r\n    if( t == \"all\" or t == \"image\") then\r\n        local folderi = self.ContentHandling.getFolderResource(\"image\")\r\n        callAddResource(folderi,self.imagePath, true, true,overrideClean)\r\n    end\r\n    if( t == \"all\" or t == \"audio\") then\r\n        local foldera = self.ContentHandling.getFolderResource(\"audio\")\r\n        callAddResource(foldera,self.audioPath, true, true,overrideClean)\r\n    end\r\n    if( t == \"all\" or t == \"other\") then\r\n        local foldero = self.ContentHandling.getFolderResource(\"other\")\r\n        callAddResource(foldero,self.otherPath, true, true,overrideClean)\r\n    end\r\nelse  \r\n    if( videoArr ~= nil) then\r\n        local folder = self.ContentHandling.getFolderResource(\"video\")\r\n        self.ContentHandling.syncDirManual(folder, self.videoPath, true, videoArr, overrideClean)\r\n    end\r\n    if( imageArr ~= nil) then\r\n        local folder = self.ContentHandling.getFolderResource(\"image\")\r\n        self.ContentHandling.syncDirManual(folder, self.imagePath, true, imageArr, overrideClean)\r\n    end\r\n    if(audioArr ~= nil) then\r\n        local folder = self.ContentHandling.getFolderResource(\"audio\")\r\n        self.ContentHandling.syncDirManual(folder, self.audioPath, true, audioArr, overrideClean)\r\n    end\r\n    if( otherArr ~= nil) then\r\n        local folder = self.ContentHandling.getFolderResource(\"other\")\r\n        self.ContentHandling.syncDirManual(folder, self.otherPath, true, otherArr, overrideClean)\r\n    end\r\nend\r\n",
     "kind": "func",
     "name": "syncToResourceFolder",
     "params": [
      {
       "name": "optionalType",
       "type": "string"
      },
      {
       "name": "videoArr",
       "type": "object"
      },
      {
       "name": "imageArr",
       "type": "object"
      },
      {
       "name": "audioArr",
       "type": "object"
      },
      {
       "name": "otherArr",
       "type": "object"
      },
      {
       "name": "overrideClean",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.syncToResourceFolder"
    },
    {
     "body": "if self.removeAssetsMode == \"Never\" or self.removeAssetsMode == \"Dayli\" then\r\n\tself.ContentHandling.syncToResourceFolder(nil,videoArr,imageArr,audioArr,otherArr,\"CLEAN_NO\"); \r\nelse\r\n\tself.ContentHandling.syncToResourceFolder(nil,videoArr,imageArr,audioArr,otherArr,\"CLEAN_FORCE\"); \r\nend  \r\n",
     "kind": "func",
     "name": "syncToResourceFolderCleanAware",
     "params": [
      {
       "name": "optionalType",
       "type": "string"
      },
      {
       "name": "videoArr",
       "type": "object"
      },
      {
       "name": "imageArr",
       "type": "object"
      },
      {
       "name": "audioArr",
       "type": "object"
      },
      {
       "name": "otherArr",
       "type": "object"
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.syncToResourceFolderCleanAware"
    },
    {
     "body": "local t = optionalType;\r\nif(optionalType == nil or optionalType == \"all\" or type(optionalType) ~= 'string') then\r\n\tt = \"all\"\r\nend\r\nif( t == \"all\" or t == \"video\") then\r\n\tlocal folder = self.ContentHandling.getFolderResource(\"video\")\r\n\tself.addedResources = folder.addResourcesFromDirectory(self.videoPath, true, true)\r\nend\r\nif( t == \"all\" or t == \"image\") then\r\n\tlocal folderi = self.ContentHandling.getFolderResource(\"image\")\r\n\tself.addedResourcesI = folderi.addResourcesFromDirectory(self.imagePath, true, true)\r\nend\r\nif( t == \"all\" or t == \"audio\") then\r\n\tlocal foldera = self.ContentHandling.getFolderResource(\"audio\")\r\n\tself.addedResourcesA = foldera.addResourcesFromDirectory(self.audioPath, true, true)\r\nend\r\nif( t == \"all\" or t == \"other\") then\r\n\tlocal foldero = self.ContentHandling.getFolderResource(\"other\")\r\n\tself.addedResourcesO = foldero.addResourcesFromDirectory(self.otherPath, true, true)\r\nend\r\n\r\n",
     "kind": "func",
     "name": "getSyncStatus",
     "params": [
      {
       "name": "id",
       "type": "int"
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.getSyncStatus"
    },
    {
     "body": "if self.downloadHandle ~= nil then\r\n\tself.downloadHandle.remove()\r\n\tself.downloadHandle = nil\r\nend\r\n",
     "kind": "func",
     "name": "cancelDownload",
     "path": "ISAACPlayer24H.ContentHandling.cancelDownload"
    },
    {
     "body": "local res = false\r\nlocal handle = nil\r\nlocal statue = nil\r\nif self.downloadHandle ~= nil then\r\n\tlocal state =  self.downloadHandle.isFinished();\r\n\tres = state;\r\nend\r\nif res == true then\r\n\tself.log(1,\"Downloader is running\")\r\nend\r\nreturn res\r\n",
     "kind": "func",
     "name": "checkRunning",
     "path": "ISAACPlayer24H.ContentHandling.checkRunning"
    },
    {
     "body": "if resourceFolderHandle == nil or resourceFolderHandle.getHandleInt() == 0 then\r\n    self.log(1,\"syncDirManual invalid resourceFolderHandle\")\r\n    return\r\nend\r\nif toAddArray == nil or type(toAddArray) ~= \"table\" then\r\n    self.log(1,\"syncDirManual invalid toAddArray\")\r\n    return\r\nend\r\ntoAddArray = self.helper.dedupArray(toAddArray)\r\n\r\nfor k,v in ipairs(toAddArray) do\r\n\t --self.log(1,\"reqired\",dirPath,k,v)\r\nend\r\nlocal curentRes = resourceFolderHandle.getResources();\r\n--self.log(1,\"currentREs\",pixcCommon.toJson(curentRes))\r\nlocal currentName= {};\r\n\r\nfor k,v in ipairs(curentRes) do\r\n\t\r\n    local name = v.getName();\r\n    currentName[name] = {};\r\n    currentName[name].hdl = v;\r\n    currentName[name].toDel = true;\r\n\t--self.log(1,\"current\",v,dirPath,name)\r\nend\r\n--self.log(1,\"currentName\",pixcCommon.toJson(currentName))\r\nfor k,v in ipairs(toAddArray) do\r\n\r\n    if currentName[v] ~= nil then\r\n\t\t--self.log(1,\"found\", currentName[v].hdl,dirPath,v)\r\n        currentName[v].toDel = false\r\n    else\r\n        local hdl = resourceFolderHandle.addResource(dirPath..\"/\"..v)\r\n        --self.log(1,\"added\", hdl,dirPath,v)\r\n        currentName[v] = {};\r\n        currentName[v].hdl = hdl;\r\n        currentName[v].toDel = false;\r\n    end\r\nend\r\n\r\n--self.log(1,\"currentName3\",pixcCommon.toJson(currentName))\r\nif overrideClean ~= nil and overrideClean == \"CLEAN_NO\" then\r\n\t--pixc.log(\"Clean No\")\r\n\treturn\r\nend\r\nif(removeOther == true) then\r\n    for k,v in pairs(currentName) do\r\n        if v.toDel == true then\r\n\t\t\tif overrideClean ~= nil and overrideClean == \"CLEAN_FORCE\" then \r\n\t\t\t\t--pixc.log(\"Clean RM Asset\",v.hdl.getName())\r\n\t\t\t\tv.hdl.removeThisIncludingAssets()\r\n\t\t\telse  \r\n\t\t\t\t--pixc.log(\"Clean RM Noraml\",v.hdl.getName())         \r\n\t\t\t\tv.hdl.removeThis()\r\n\t\t\tend\r\n        end\r\n    end\r\nend\r\n",
     "kind": "func",
     "name": "syncDirManual",
     "params": [
      {
       "name": "resourceFolderHandle",
       "type": "object"
      },
      {
       "name": "dirPath",
       "type": "string"
      },
      {
       "name": "removeOther",
       "type": "bool"
      },
      {
       "name": "toAddArray",
       "type": "object"
      },
      {
       "name": "overrideClean",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.syncDirManual"
    },
    {
     "body": "if self.checkPendingTransfers == false then\r\n    return false\r\nend\r\n\r\nif resourceFolderHandle == nil or resourceFolderHandle.getHandleInt() == 0 then\r\n    self.log(1,\"check pending transfers: invalid Resource-Folder-Handle\")\r\n    return\r\nend\r\n\r\nlocal curentRes = resourceFolderHandle.getResources();\r\nif wait == true then\r\n    for k,v in ipairs(curentRes) do\r\n        while v.getHasPendingTransfer() do      \r\n            self.log(1,\"TransversPending: \",v.getName())\r\n            Utils.Timer.sleep('1000ms') \r\n\t\t\tif(self.stop) then\r\n\t\t\t\treturn false\r\n\t\t\tend       \r\n        end\r\n    end\r\nelse\r\n    for k,v in ipairs(curentRes) do\r\n        if v.getHasPendingTransfer() then      \r\n            return true    \r\n        end\r\n    end\r\nend\r\nreturn false\r\n",
     "kind": "func",
     "name": "checkPendingTransfers",
     "params": [
      {
       "name": "resourceFolderHandle",
       "type": "object"
      },
      {
       "name": "wait",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.checkPendingTransfers"
    },
    {
     "body": "local hdlCheckVersion =  pixc.getRoot().Pixera.Resources.getResourceFolderWithNamePath(\"Media/dsfztfashdsfjhgfvstzfwesujfvbsgujfvjsedwrfvzugsbtzuwecvje\")\r\nif(hdlCheckVersion ~= nil) then\r\n\tself.log(1,\"UPDATE of Pixera require\")\r\n\treturn\r\nend\r\n\r\nlocal reqPath = root..\"/\"..subpath\r\nlocal hdlRoot =  pixc.getRoot().Pixera.Resources.getResourceFolderWithNamePath(root)\r\nif hdlRoot == nil then\r\n\tself.log(1,\"addResourceFolderIfMissing invalid root\",root);\r\n\treturn\r\nend\r\n\r\nlocal sPath = self.helper.stringSplit(subpath,\"/\");\r\nlocal currentPath = root;\r\nfor  i = 1, #sPath,1 do\r\n\tcurrentPath = currentPath..\"/\"..sPath[i];\r\n\tlocal hdlC =  pixc.getRoot().Pixera.Resources.getResourceFolderWithNamePath(currentPath)\r\n\tif hdlC == nil then\r\n\t\thdlRoot.createFoldersFrom(sPath[i]);\r\n\tend\r\n\thdlRoot =  pixc.getRoot().Pixera.Resources.getResourceFolderWithNamePath(currentPath)\r\n\tif (hdlRoot == nil) then\r\n\t\tself.log(1,\"Error Creating ResourcePath\",currentPath)\r\n\t\treturn\r\n\tend\r\nend\r\n\r\n",
     "kind": "func",
     "name": "addResourceFolderIfMissing",
     "params": [
      {
       "name": "root",
       "type": "string"
      },
      {
       "name": "subpath",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.addResourceFolderIfMissing"
    },
    {
     "body": "if wait == true then\r\n    local a = self.ContentHandling.getFolderResource(\"video\")\r\n    self.ContentHandling.checkPendingTransfers(a,true)\r\n    local b = self.ContentHandling.getFolderResource(\"image\")\r\n    self.ContentHandling.checkPendingTransfers(b,true)\r\n    local c = self.ContentHandling.getFolderResource(\"audio\")\r\n    self.ContentHandling.checkPendingTransfers(c,true)\r\n    local d = self.ContentHandling.getFolderResource(\"other\")\r\n    self.ContentHandling.checkPendingTransfers(d,true)\r\nelse\r\n    local a = self.ContentHandling.getFolderResource(\"video\")\r\n    if self.ContentHandling.checkPendingTransfers(a) == true then\r\n        return true\r\n    end\r\n\r\n    local b = self.ContentHandling.getFolderResource(\"image\")\r\n      if self.ContentHandling.checkPendingTransfers(b) == true then\r\n        return true\r\n    end\r\n    local c = self.ContentHandling.getFolderResource(\"audio\")\r\n      if self.ContentHandling.checkPendingTransfers(c) == true then\r\n        return true\r\n    end\r\n    local d = self.ContentHandling.getFolderResource(\"other\")\r\n      if self.ContentHandling.checkPendingTransfers(d) == true then\r\n        return true\r\n    end\r\nend\r\n\r\n",
     "kind": "func",
     "name": "isTransferFinished",
     "params": [
      {
       "name": "wait",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.ContentHandling.isTransferFinished"
    },
    {
     "body": "local h,m,s = self.Helper.getTimeNowLocal()\r\nlocal now = h*60 +m;\r\nlocal rmTime = self.removeAssetTime\r\nif self.oldRmTime == nil or self.oldRmTime ~= rmTime then\r\n\tself.cleanDone = false;\r\nend\r\nself.oldRmTime = rmTime\r\nlocal diff = now - rmTime;\r\n--pixc.log(now,self.removeTime,diff)\r\nif now > self.removeTime then\r\n\tif self.cleanDone == nil or self.cleanDone == false then\r\n\t\treturn true\r\n\tend\t\r\nelse\r\n\tself.cleanDone = false;\r\nend\t\t\r\nreturn false\r\n",
     "kind": "func",
     "name": "isDayliCleanRequired",
     "path": "ISAACPlayer24H.ContentHandling.isDayliCleanRequired"
    },
    {
     "body": "self.cleanDone = true;\r\n",
     "kind": "func",
     "name": "dayliCleanDone",
     "path": "ISAACPlayer24H.ContentHandling.dayliCleanDone"
    }
   ],
   "kind": "ns",
   "name": "ContentHandling"
  },
  {
   "elems": [
    {
     "body": "local res = self.ContentHandling.getHandleFormMedia(\"video\",filename)\r\nself.log(1,\"Loop Ressource\",res, res.getName())\r\n\r\nlocal tl1 = self.TimelineMain()\r\nself.Player.cleanTimeline(1,\"Play loop begin\")\r\nlocal layer = Pixera.Timelines.Layer.getInst(tl1.getName() .. \".\" .. self.layerPlayName)\r\nif layer == nil or layer.getHandleInt() == 0 then\r\n\treturn\r\nend\r\n\r\nlocal fps = tl1.getFps();\r\nlocal duration = res.getDuration()\r\n--pixc.log(\"Dur\",optDuration, type(optDuration))\r\nif optDuration ~= nil  then\r\n\tlocal n =  tonumber(optDuration)\r\n\tif(n ~= nil) then\r\n\t\tduration = n/1000;\r\n\tend\r\nend\r\nlocal time = 0;\r\nlocal endTime = 0;\r\n\r\nif duration < 1 then\r\n\tduration = 1\r\nend\r\n--local multipliedDuration = duration\r\n--while multipliedDuration < 10 do\r\n--\tmultipliedDuration = multipliedDuration + duration\r\n--end\r\nself.instLastTime = nil\r\nlocal clip = layer.createClip(0)\r\nif clip ~= nil then\r\n\tclip.setDuration(self.loopCue24Pos+1)\r\n\t--clip.setTime(time * fps)\r\n\tclip.assignResource(res.getId())\r\n\tclip.setDuration(self.loopCue24Pos+1)\r\n\tendTime = self.loopCue24Pos+1\r\n\tclip.setPlayMode(3)\r\n\tself.loopClip = clip\r\nend\r\nself.Player.run24Timeline()\r\n\r\n",
     "kind": "func",
     "name": "playLoop",
     "params": [
      {
       "name": "filename",
       "type": "string"
      },
      {
       "name": "optDuration",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.TimelineHandling.playLoop"
    },
    {
     "body": "local tl1 = self.TimelineMain()\r\nself.Player.cleanTimeline(1,\"Loop custom begin\")\r\nlocal layer = Pixera.Timelines.Layer.getInst(tl1.getName() .. \".\" .. self.layerPlayName)\r\nif layer == nil or layer.getHandleInt() == 0 then\r\n\treturn\r\nend\r\nself.instLastTime = nil\r\nlocal fps = tl1.getFps();\r\nlocal time = 0;\r\nlocal endTime = 0;\r\nif duration > 0 then\r\n\tlocal clip = layer.createClip(0);\r\n\tendTime = duration/1000\r\n\tclip.setDuration(endTime*fps)\r\n\tself.Hooks.customPlayable(command,tl1,0)\r\n\t\r\n\tif endTime > 1 then\r\n\t\tlocal cue = tl1.createCue(\"Loop\", endTime * fps - 1, 4)\r\n\t\tif cue ~= nil then\r\n\t\t\tcue.setJumpGoalTime(0)\r\n\t\tend\r\n\tend\r\n\tself.loopClip = clip\r\n\tif(tl1.getCurrentTime() > self.InstantPlayPos-10 ) then -- is in instant Play\r\n\r\n\telse  -- Schedule or Loop\r\n\t\ttl1.setCurrentTime(0)\r\n\t\ttl1.play()\r\n\tend\r\nend\r\n\r\n",
     "kind": "func",
     "name": "playLoopCustom",
     "params": [
      {
       "name": "command",
       "type": "string"
      },
      {
       "name": "duration",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.TimelineHandling.playLoopCustom"
    },
    {
     "body": "\r\nif timeline == nil then return end\r\n\r\nlocal tBegin = 0;\r\nlocal tEnd = 24*60*60;\r\n\r\nif type(beginS) == \"number\" then\r\n\ttBegin = beginsS\r\nend\r\n\r\nif type(EndS) == \"number\" then\r\n\ttEnd = endS\r\nend\r\n\r\nif tBegin < 0 then return end\r\nif tEnd < 0 then return end\r\nif tEnd < tBegin then return end\r\n\r\n",
     "kind": "func",
     "name": "cleanTimelineInRange",
     "params": [
      {
       "name": "timeline",
       "type": ""
      },
      {
       "name": "beginS",
       "type": ""
      },
      {
       "name": "endS",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.TimelineHandling.cleanTimelineInRange"
    },
    {
     "body": "local tl1 = self.TimelineMain()\r\n\r\nself.Helper.pauseTimelineUpdates()\r\nself.Player.cleanTimeline(1,\"Play loop Composition begin\")\r\n\r\nfor k,v in pairs(self.playingstatus.loopComposition) do\r\n\tlocal layer,info = self.Composition.getLayerId(k)\r\n\tlocal typ,nr,uid = self.Composition.helper.parseId(k)\r\n\tlocal resource = nil\r\n\tif typ == nil  or typ == \"med\" then --defautl compostion or media\r\n\t\tresource = self.ContentHandling.getHandleFormMedia(\"video\",v.objectName) \t\t\r\n\tend \r\n\tif typ == \"lis\" then\r\n\t\tlocal liveInputnamne = v;\t\r\n\t\tresource = self.ContentHandling.getLiveInput(liveInputnamne);\r\n\t\tlayer, info = self.Composition.getLayerId(k)\r\n\tend\r\n\tif(layer~= nil and resource ~= nil) then\r\n\t\tlocal clip = layer.createClip(0)\r\n\t\tif clip ~= nil then\r\n\t\t\tclip.setDuration(self.loopCue24Pos+1)\r\n\t\t\t--clip.setTime(time * fps)\r\n\t\t\tclip.assignResource(resource.getId())\r\n\t\t\tclip.setDuration(self.loopCue24Pos+1)\r\n\t\t\tendTime = self.loopCue24Pos+1\r\n\t\t\tclip.setPlayMode(3)\r\n\t\t\tself.loopClip = clip\r\n\t\tend\r\n\tend\r\nend\r\n\r\nself.Player.run24Timeline()\r\n\r\n",
     "kind": "func",
     "name": "playLoopComposition",
     "params": [
      {
       "name": "command",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.TimelineHandling.playLoopComposition"
    }
   ],
   "kind": "ns",
   "name": "TimelineHandling"
  },
  {
   "body": "local refs = pixc.callRefs()\r\nif refs == nil or refs[1] == nil or refs[1][1] == nil then\r\n\treturn Pixera\r\nend\r\nreturn refs[1][1]\r\n",
   "kind": "func",
   "name": "Pixera",
   "path": "ISAACPlayer24H.Pixera"
  },
  {
   "body": "if self.timelineMainHandle ~= nil then\r\n\treturn self.timelineMainHandle\r\nend\r\n\r\nlocal refs = pixc.callRefs()\r\nlocal result = {}\r\nif refs == nil or refs[1] == nil or refs[1][1] == nil then\r\n\tif self.log ~= nil then self.log(1,\"Timeline Main\",pixcCommon.toJson(result)) end\r\n\treturn nil\r\nend\r\n\r\nreturn refs[1][1]\r\n\r\n",
   "kind": "func",
   "name": "TimelineMain",
   "path": "ISAACPlayer24H.TimelineMain"
  },
  {
   "body": "if self.timelineInstantHandle ~= nil then\r\n\treturn self.timelineInstantHandle\r\nend\r\n\r\nlocal refs = pixc.callRefs()\r\nlocal result = {}\r\nif refs == nil or refs[1] == nil or refs[1][1] == nil then\r\n\treturn nil\r\nend\r\n\r\nreturn refs[1][1]\r\n\r\n",
   "kind": "func",
   "name": "TimelineInstant",
   "path": "ISAACPlayer24H.TimelineInstant"
  },
  {
   "body": "local px = self.Pixera()\r\nif self.lSys ~= nil then\r\n\treturn self.lSys\r\nend\r\nif ( px ~= nil) then\r\n\tlocal lSys = px.LiveSystems.getLiveSystems();\r\n\r\n\tif ( lSys ~= nil ) then\r\n\t\tfor i = 1 , #lSys do\r\n\t\t\tlocal sys = lSys[i]\r\n\t\t\tif(sys ~= nil and sys.getName() == self.LiveSystemToMonitor) then\r\n\t\t\t\tself.lSys = sys;\r\n\t\t\t\treturn self.lSys\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\n",
   "kind": "func",
   "name": "LiveSystem",
   "path": "ISAACPlayer24H.LiveSystem"
  },
  {
   "elems": [
    {
     "body": "local res = pixc.callRefs(url ,externalmoduleid, ...)\r\nif type(res) ~= 'table' or #res ~= 1 then\r\n\treturn nil\r\nend\r\nreturn table.unpack(res[1])\r\n",
     "kind": "func",
     "name": "postMediaSync",
     "params": [
      {
       "name": "url",
       "type": "string"
      },
      {
       "name": "externalmoduleid",
       "type": "string"
      },
      {
       "name": "...",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Hooks.postMediaSync"
    },
    {
     "body": "",
     "kind": "func",
     "name": "customPlayable",
     "params": [
      {
       "name": "upcomingPlayable",
       "type": ""
      },
      {
       "name": "targetTimeline",
       "type": ""
      },
      {
       "name": "timelineOffset",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Hooks.customPlayable"
    },
    {
     "body": "",
     "kind": "func",
     "name": "postPlayableAdded",
     "params": [
      {
       "name": "upcomingPlayable",
       "type": ""
      },
      {
       "name": "targetTimeline",
       "type": ""
      },
      {
       "name": "layer",
       "type": ""
      },
      {
       "name": "timelineOffset",
       "type": ""
      },
      {
       "name": "duration",
       "type": ""
      },
      {
       "name": "...",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Hooks.postPlayableAdded"
    },
    {
     "body": "self.log(1,\"Customtransiton\",pixcCommon.toJson(endingPlayable),pixcCommon.toJson(upcomingPlayable),targetTimeline,timelineOffset,duration)\r\n",
     "kind": "func",
     "name": "customTransition",
     "params": [
      {
       "name": "dummy",
       "type": ""
      },
      {
       "name": "endingPlayable",
       "type": ""
      },
      {
       "name": "upcomingPlayable",
       "type": ""
      },
      {
       "name": "targetTimeline",
       "type": ""
      },
      {
       "name": "timelineOffset",
       "type": ""
      },
      {
       "name": "duration",
       "type": ""
      },
      {
       "name": "...",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Hooks.customTransition"
    },
    {
     "body": "",
     "kind": "func",
     "name": "cleanTimeline",
     "params": [
      {
       "name": "dummy",
       "type": ""
      },
      {
       "name": "timeline",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Hooks.cleanTimeline"
    }
   ],
   "kind": "ns",
   "name": "Hooks"
  },
  {
   "elems": [
    {
     "attKind": "internal",
     "body": "self._currentMedia = pixcCommon.execAttribute(0, self._currentMedia, val, doSet,false)\r\n\r\nreturn self._currentMedia\r\n",
     "kind": "func",
     "name": "currentMedia",
     "params": [
      {
       "name": "val",
       "type": ""
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.currentMedia"
    },
    {
     "attKind": "internal",
     "body": "self._currentMediaStatus = pixcCommon.execAttribute(0, self._currentMediaStatus, val, doSet,false)\r\n\r\nreturn self._currentMediaStatus\r\n",
     "kind": "func",
     "name": "currentMediaStatus",
     "params": [
      {
       "name": "val",
       "type": ""
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.currentMediaStatus"
    },
    {
     "attKind": "internal",
     "body": "self._MemoryUsage = pixcCommon.execAttribute(0, self._MemoryUsage, val, doSet,false)\r\n\r\nreturn self._MemoryUsage\r\n",
     "kind": "func",
     "name": "MemoryUsage",
     "params": [
      {
       "name": "val",
       "type": ""
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.MemoryUsage"
    },
    {
     "attKind": "internal",
     "body": "self._CpuUsage = pixcCommon.execAttribute(0, self._CpuUsage, val, doSet,false)\r\n\r\nreturn self._CpuUsage\r\n",
     "kind": "func",
     "name": "CpuUsage",
     "params": [
      {
       "name": "val",
       "type": ""
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.CpuUsage"
    },
    {
     "attKind": "internal",
     "body": "self._TransitionMedia = pixcCommon.execAttribute(0, self._TransitionMedia, val, doSet,false)\r\n\r\nreturn self._TransitionMedia\r\n",
     "kind": "func",
     "name": "TransitionMedia",
     "params": [
      {
       "name": "val",
       "type": ""
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.TransitionMedia"
    },
    {
     "attKind": "internal",
     "body": "self._TransitionMode = pixcCommon.execAttribute(0, self._TransitionMode, val, doSet,false)\r\n\r\nreturn self._TransitionMode\r\n",
     "kind": "func",
     "name": "TransitionMode",
     "params": [
      {
       "name": "val",
       "type": ""
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.TransitionMode"
    },
    {
     "attKind": "internal",
     "body": "self._TransitionStatus = pixcCommon.execAttribute(0, self._TransitionStatus, val, doSet,false)\r\n\r\nreturn self._TransitionStatus\r\n",
     "kind": "func",
     "name": "TransitionStatus",
     "params": [
      {
       "name": "val",
       "type": ""
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.TransitionStatus"
    },
    {
     "attKind": "internal",
     "body": "self._PlayInstantMode = pixcCommon.execAttribute(0, self._PlayInstantMode, val, doSet,false)\r\n\r\nreturn self._PlayInstantMode\r\n",
     "kind": "func",
     "name": "PlayInstantMode",
     "params": [
      {
       "name": "val",
       "type": ""
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.PlayInstantMode"
    },
    {
     "attKind": "internal",
     "body": "self._PlayInstantModeFile = pixcCommon.execAttribute(0, self._PlayInstantModeFile, val, doSet,false)\r\n\r\nreturn self._PlayInstantModeFile\r\n",
     "kind": "func",
     "name": "PlayInstantModeFile",
     "params": [
      {
       "name": "val",
       "type": ""
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.PlayInstantModeFile"
    },
    {
     "attKind": "internal",
     "body": "self._StatusOK = pixcCommon.execAttribute(0, self._StatusOK, val, doSet,false)\r\n\r\nreturn self._StatusOK\r\n",
     "kind": "func",
     "name": "StatusOK",
     "params": [
      {
       "name": "val",
       "type": ""
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.StatusOK"
    },
    {
     "attKind": "internal",
     "body": "self._HeartbeatOK = pixcCommon.execAttribute(0, self._HeartbeatOK, val, doSet,false)\r\n\r\nreturn self._HeartbeatOK\r\n",
     "kind": "func",
     "name": "HeartbeatOK",
     "params": [
      {
       "name": "val",
       "type": ""
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.HeartbeatOK"
    },
    {
     "attKind": "internal",
     "body": "self._CurrentMediaTime = pixcCommon.execAttribute(\"\", self._CurrentMediaTime, val, doSet)\r\n\r\nreturn self._CurrentMediaTime\r\n",
     "kind": "func",
     "name": "CurrentMediaTime",
     "params": [
      {
       "name": "val",
       "type": "string"
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.CurrentMediaTime",
     "result": {
      "name": "result",
      "type": "string"
     }
    },
    {
     "attKind": "internal",
     "body": "self._PlayInstantMediaTime = pixcCommon.execAttribute(\"\", self._PlayInstantMediaTime, val, doSet,false)\r\n\r\nreturn self._PlayInstantMediaTime\r\n",
     "kind": "func",
     "name": "PlayInstantMediaTime",
     "params": [
      {
       "name": "val",
       "type": "string"
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.PlayInstantMediaTime",
     "result": {
      "name": "result",
      "type": "string"
     }
    },
    {
     "attKind": "internal",
     "body": "self._TransitionMediaTime = pixcCommon.execAttribute(\"\", self._TransitionMediaTime, val, doSet,false)\r\n\r\nreturn self._TransitionMediaTime\r\n",
     "kind": "func",
     "name": "TransitionMediaTime",
     "params": [
      {
       "name": "val",
       "type": "string"
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.TransitionMediaTime",
     "result": {
      "name": "result",
      "type": "string"
     }
    },
    {
     "attKind": "internal",
     "body": "self._PlayInstantModeStatus = pixcCommon.execAttribute(0, self._PlayInstantModeStatus, val, doSet,false)\r\n\r\nreturn self._PlayInstantModeStatus\r\n",
     "kind": "func",
     "name": "PlayInstantModeStatus",
     "params": [
      {
       "name": "val",
       "type": "int"
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.PlayInstantModeStatus",
     "result": {
      "name": "result",
      "type": "int"
     }
    },
    {
     "attKind": "internal",
     "body": "pixc.report(\"\")\r\nif doSet == nil or doSet == false then\r\n\tpixc.suppressCallRefs()\r\nend\r\nself._ErrorList = val   --pixcCommon.execAttribute(\"\", {}, val, doSet)\r\npixc.callRefs(self._ErrorList)\r\n\r\n--if self.jsonlib == nil then\r\n--\tself.jsonlib = require \"json\" \r\n--end\r\n--pixc.log(\"aaaa\" ,self.jsonlib.encode(self._ErrorList))\r\nreturn self._ErrorList\r\n",
     "kind": "func",
     "name": "ErrorList",
     "params": [
      {
       "name": "val",
       "type": "string"
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.ErrorList",
     "result": {
      "name": "result",
      "type": "string"
     }
    },
    {
     "attKind": "internal",
     "body": "self._started = pixcCommon.execAttribute(false, self._started, val, doSet)\r\nreturn self._started\r\n",
     "kind": "func",
     "name": "started",
     "params": [
      {
       "name": "val",
       "type": "bool"
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.started",
     "result": {
      "name": "result",
      "type": "bool"
     }
    },
    {
     "body": "if(val == true and doSet == true) then\r\n\tself.init()\r\nend\r\n\r\nif(val == false and doSet == true) then\r\n\tself.uninit()\r\nend\r\n",
     "kind": "func",
     "name": "start",
     "params": [
      {
       "name": "val",
       "type": "bool"
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.start",
     "result": {
      "name": "result",
      "type": "bool"
     }
    },
    {
     "body": "self.UI.ModuleName(self()..\"\",true)\r\nself.UI.ErrorList(self.errorList,true)\r\n",
     "kind": "func",
     "name": "onLoad",
     "path": "ISAACPlayer24H.UI.onLoad"
    },
    {
     "attKind": "standard",
     "attReports": {
      "0": "false"
     },
     "body": "self._Maintenance = pixcCommon.execAttribute(false, self._Maintenance, val, doSet)\r\nreturn self._Maintenance\r\n",
     "kind": "func",
     "name": "Maintenance",
     "params": [
      {
       "name": "val",
       "type": "bool"
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.Maintenance",
     "result": {
      "name": "result",
      "type": "bool"
     }
    },
    {
     "attKind": "internal",
     "body": "self._ModuleName = pixcCommon.execAttribute(\"\", self._ModuleName, val, doSet)\r\nreturn self._ModuleName\r\n",
     "kind": "func",
     "name": "ModuleName",
     "params": [
      {
       "name": "val",
       "type": "string"
      },
      {
       "name": "doSet",
       "type": "bool"
      }
     ],
     "path": "ISAACPlayer24H.UI.ModuleName",
     "result": {
      "name": "result",
      "type": "string"
     }
    }
   ],
   "kind": "ns",
   "name": "UI"
  },
  {
   "elems": [
    {
     "body": "local now = pixc.getRoot().Utils.Timer.now();\r\nlocal timeStringNow = pixc.getRoot().Utils.Timer.toStringLocal(now)\r\n--pixc.log(timeStringNow,errormsg)\r\nlocal errorStr = \"\"\r\nif type == nil then\r\n\ttype = \"NA\"\r\nend\r\nlocal obj = {}\r\nobj.value = timeStringNow..\" | \"..errormsg\r\nif self.log ~= nil then\r\n\tself.log(1,errormsg)\r\nend\r\nif(type ~= nil) then\r\n\tif(type == \"warning\") then\r\n\t\tobj.color = \"#FFA600\"\r\n\tend\r\n\tif(type == \"error\") then\r\n\t\tobj.color = \"#FF0000\"\r\n\tend\r\n\tif(type == \"info\") then\r\n\t\tobj.color = \"#2aec71\"\r\n\tend\r\nend\r\nif self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\nif(self.errorList == nil ) then return end\r\ntable.insert(self.errorList,obj)\r\nlocal len = #self.errorList\r\nif(self.maxWebLogLength > 0) then \r\n\tif len > self.maxWebLogLength then\r\n\t\ttable.remove(self.errorList,1)\r\n\tend\r\nend\r\nself.UI.ErrorList(self.errorList,true)\r\n",
     "kind": "func",
     "name": "addError",
     "params": [
      {
       "name": "errormsg",
       "type": "string"
      },
      {
       "name": "type",
       "type": "string"
      }
     ],
     "path": "ISAACPlayer24H.Errorhelper.addError"
    },
    {
     "body": "self.errorList = {}\r\nself.UI.ErrorList(nil,true)\r\n",
     "kind": "func",
     "name": "clearErrors",
     "path": "ISAACPlayer24H.Errorhelper.clearErrors"
    }
   ],
   "kind": "ns",
   "name": "Errorhelper"
  },
  {
   "elems": [
    {
     "body": "if self.protocol == nil then self.log(1,\"not initialized\") return end\r\n--\r\nif self.jsonlib == nil then\r\n\tself.jsonlib = require \"json\" \r\nend\r\n\r\n\r\nlocal parameter = {}\r\nlocal customHeader={\"Content-Type: application/json\",apiKeyHeader}\r\nlocal url = self.url..\"/api/v1/playables/templates\"\r\nlocal success, code, headerDict, content = self.protocol:httpGet(url,parameter)\r\nif(success) then\r\n\tif( code == 200) then\r\n\t\tself.compositionTemplates = self.jsonlib.decode(content)\r\n\t\tself.Composition.filterCompositionTemplates()\r\n\t\tself.Composition.setCompositionMapping()\r\n\t\tself.Composition.createLayersForCompositions()\r\n\tend\r\nend\r\n\r\n\r\n\r\n",
     "kind": "func",
     "name": "loadCompositionTemplates",
     "path": "ISAACPlayer24H.Composition.loadCompositionTemplates"
    },
    {
     "body": "\r\nif(self.compositionTemplates == nil) then return end\r\nlocal isInGroupe = function(group)\r\n\t\tfor k,v in ipairs(self.compositionsGroupes) do\r\n\t\t\tif v == group then \r\n\t\t\t\treturn true \r\n\t\t\tend\r\n\t\tend\r\n\t\treturn false\r\n\tend\r\n\r\nlocal rmFunc = function(t,i,j,ext) \r\n\tif(isInGroupe(t[i].templatePath.group) == true) then\r\n\t\treturn true\r\n\telse\r\n\t\treturn false\r\n\tend\r\nend\r\n\r\nself.helper.arrayRemove(self.compositionTemplates,rmFunc,nil,nil)\r\n",
     "kind": "func",
     "name": "filterCompositionTemplates",
     "path": "ISAACPlayer24H.Composition.filterCompositionTemplates"
    },
    {
     "body": "\r\n\r\nlocal f = function (tl)\r\n\tlocal tlName = tl.getName()\r\n\tfor k,v in pairs(self.compositionMapping) do\r\n\t\tlocal l = Pixera.Timelines.Layer.getInst( tlName.. \".\" .. v.layer)\r\n\t\tif l == nil or l.getHandleInt() == 0 then\r\n\t\t\tl = tl.createLayer()\r\n\t\t\tl.setName(v.layer)\r\n\t\telse\r\n\t\t\tl.removeClips()\r\n\t\tend\r\n\tend\r\nend\r\nf(self.TimelineMain())\r\nif(self.enableInstantPlay == true) then\r\n\tf(self.TimelineInstant())\r\nend\r\n",
     "kind": "func",
     "name": "createLayersForCompositions",
     "path": "ISAACPlayer24H.Composition.createLayersForCompositions"
    },
    {
     "body": "self.compositionMapping = {}\r\n\r\nfor k,v in ipairs(self.compositionTemplates) do\r\n\tif(v.uiElements ~= nil) then\r\n\t\tlocal liveDurations = {}\r\n\t\tlocal transitionCombo = {}\r\n\t\tlocal currentIds = {}\r\n\t\tfor i,d in ipairs(v.uiElements) do\r\n\t\t\tif d.id ~= nil then\r\n\t\t\t\tlocal typ,nr,uid = self.Composition.helper.parseId(d.id)\r\n\t\t\t\tif( typ ~= nil) then\r\n\t\t\t\t\t\r\n\t\t\t\t\tif typ == \"med\" then\r\n\t\t\t\t\t\tif self.compositionMapping[d.id] == nil then self.compositionMapping[d.id] = {} end\r\n\t\t\t\t\t\tself.compositionMapping[d.id].layer = d.displayName\r\n\t\t\t\t\t\tself.compositionMapping[d.id].name = d.displayName\r\n\t\t\t\t\t\tself.compositionMapping[d.id].numId = nr\r\n\t\t\t\t\t\tself.compositionMapping[d.id].typ = \"med\"\r\n\t\t\t\t\t\tcurrentIds[d.id] = true\r\n\t\t\t\t\tend\r\n\t\t\t\t\tif typ == \"lis\" and d.type == \"combo\" then\r\n\t\t\t\t\t\tif self.compositionMapping[d.id] == nil then self.compositionMapping[d.id] = {} end\r\n\t\t\t\t\t\tself.compositionMapping[d.id].isLiveInput = true\r\n\t\t\t\t\t\tself.compositionMapping[d.id].layer = d.displayName\r\n\t\t\t\t\t\tself.compositionMapping[d.id].name = d.displayName\r\n\t\t\t\t\t\tself.compositionMapping[d.id].numId = nr\r\n\t\t\t\t\t\tself.compositionMapping[d.id].typ = \"lis\"\r\n\t\t\t\t\t\tcurrentIds[d.id] = true\r\n\t\t\t\t\t\tself.transitionTemplates[v.templatePath._id] = true\r\n\t\t\t\t\tend\r\n\t\t\t\t\tif typ == \"lid\" and d.type == \"duration\" then\r\n\t\t\t\t\t\tliveDurations[nr] = d.id\r\n\t\t\t\t\tend\r\n\t\t\t\t\tif typ == \"tri\" then\r\n\t\t\t\t\t\tif self.compositionMapping[d.id] == nil then self.compositionMapping[d.id] = {} end\r\n\t\t\t\t\t\tpixc.log(\"mr\",self.mergeTransitionToLayer,self.layerBlendName)\r\n\t\t\t\t\t\tif(self.mergeTransitionToLayer == true) then\r\n\t\t\t\t\t\t\tself.compositionMapping[d.id].layer = self.layerBlendName\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tself.compositionMapping[d.id].layer = d.displayName\r\n\t\t\t\t\t\tend\t\t\t\t\r\n\t\t\t\t\t\tpixc.log(self.compositionMapping[d.id].layer)\t\r\n\t\t\t\t\t\tself.compositionMapping[d.id].name = d.displayName\r\n\t\t\t\t\t\tself.compositionMapping[d.id].numId = nr\r\n\t\t\t\t\t\tself.compositionMapping[d.id].transitionMode = \"in\"\r\n\t\t\t\t\t\tcurrentIds[d.id] = true\r\n\t\t\t\t\t\tself.transitionTemplates[v.templatePath._id] = true\r\n\t\t\t\t\t\tself.compositionMapping[d.id].typ = \"tri\"\r\n\t\t\t\t\tend\r\n\t\t\t\t\tif typ == \"tro\" then\r\n\t\t\t\t\t\tif self.compositionMapping[d.id] == nil then self.compositionMapping[d.id] = {} end\r\n\t\t\t\t\t\tif(self.mergeTransitionToLayer == true) then\r\n\t\t\t\t\t\t\tself.compositionMapping[d.id].layer = self.layerBlendName\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tself.compositionMapping[d.id].layer = d.displayName\r\n\t\t\t\t\t\tend\t\t\t\t\t\t\r\n\t\t\t\t\t\tself.compositionMapping[d.id].name = d.displayName\r\n\t\t\t\t\t\tself.compositionMapping[d.id].numId = nr\r\n\t\t\t\t\t\tself.compositionMapping[d.id].transitionMode = \"out\"\r\n\t\t\t\t\t\tcurrentIds[d.id] = true\r\n\t\t\t\t\t\tself.transitionTemplates[v.templatePath._id] = true\r\n\t\t\t\t\t\tself.compositionMapping[d.id].typ = \"tro\"\r\n\t\t\t\t\tend\r\n\t\t\t\t\tif typ == \"trc\" then\r\n\t\t\t\t\t\ttransitionCombo[nr] = d.id\r\n\t\t\t\t\tend\r\n\t\t\t\telse\r\n\t\t\t\t\tif(d.type ~= nil and d.type == \"mediaSelector\") then\r\n\t\t\t\t\t\tif self.compositionMapping[d.id] == nil then self.compositionMapping[d.id] = {} end\r\n\t\t\t\t\t\tself.compositionMapping[d.id].name = d.displayName\r\n\t\t\t\t\t\tself.compositionMapping[d.id].layer = d.displayName\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\t\r\n\t\tend\r\n\r\n\t\tfor k,v in pairs(self.compositionMapping) do\r\n\t\t\tif v.isLiveInput == true then\r\n\t\t\t\tif currentIds[k] == true then\r\n\t\t\t\t\tif liveDurations[v.numId] ~= nil then\r\n\t\t\t\t\t\tv.liveDurationId = liveDurations[v.numId]\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\tif v.transitionMode == \"in\" then\r\n\t\t\t\tif currentIds[k] == true then\r\n\t\t\t\t\tif transitionCombo[v.numId] ~= nil then\r\n\t\t\t\t\t\tv.transitionCombo = transitionCombo[v.numId]\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\tif v.transitionMode == \"out\" then\r\n\t\t\t\tif currentIds[k] == true then\r\n\t\t\t\t\tif transitionCombo[v.numId] ~= nil then\r\n\t\t\t\t\t\tv.transitionCombo = transitionCombo[v.numId]\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\n\r\nself.Helper.requireJson();\r\n--pixc.log(self.jsonlib.encode(self.compositionMapping))\r\n--pixc.log(self.jsonlib.encode(self.transitionTemplates))\r\n",
     "kind": "func",
     "name": "setCompositionMapping",
     "path": "ISAACPlayer24H.Composition.setCompositionMapping"
    },
    {
     "body": "local mapped = self.compositionMapping[id]\r\nif(mapped == nil ) then return end\r\nlocal tl = nil\r\nif isInstant == true then\r\n\ttl = self.TimelineInstant()\r\nelse\r\n\ttl = self.TimelineMain()\r\nend\r\nlocal tlName = tl.getName()\r\nlocal l = Pixera.Timelines.Layer.getInst( tlName.. \".\" .. mapped.layer)\r\nreturn l,mapped\r\n",
     "kind": "func",
     "name": "getLayerId",
     "params": [
      {
       "name": "id",
       "type": ""
      },
      {
       "name": "isInstant",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Composition.getLayerId"
    },
    {
     "body": "return self.compositionMapping[id]\r\n",
     "kind": "func",
     "name": "getMapping",
     "params": [
      {
       "name": "id",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Composition.getMapping"
    },
    {
     "body": "local layers = {}\r\nif self.compositionMapping == nil then return end\r\nlocal tlName = tl.getName()\r\nfor k,v in pairs(self.compositionMapping) do\r\n\tlocal l = Pixera.Timelines.Layer.getInst( tlName.. \".\" ..v.layer )\r\n\tlayers[k] = l\r\nend\r\nreturn layers\r\n",
     "kind": "func",
     "name": "getCompositionLayers",
     "params": [
      {
       "name": "tl",
       "type": ""
      }
     ],
     "path": "ISAACPlayer24H.Composition.getCompositionLayers"
    },
    {
     "body": "if self.Composition.helper == nil then\r\n\tself.Composition.helper = {}\r\n\r\n\t\r\n\tself.Composition.helper.parseId = function(id)\r\n\t\tlocal _, _, a, b,c = string.find(id, \"(%a+)_(%w+)_(%w+)\")\r\n\t\tif(a == nil or b == nil or c == nil) then\r\n\t\t\treturn nil\r\n\t\telse\r\n\t\t\treturn a,b,c\r\n\t\tend\r\n\tend\r\n\r\n\r\nend",
     "kind": "func",
     "name": "registerHelper",
     "path": "ISAACPlayer24H.Composition.registerHelper"
    }
   ],
   "kind": "ns",
   "name": "Composition"
  }
 ],
 "auxPath": "ISAACPlayer24H",
 "canHaveExternalConnections": false,
 "cjv": {
  "h": 539.0,
  "w": 407.0,
  "x": 464.0118577075099,
  "y": 121.57312252964428
 },
 "definedExternally": false,
 "hostInfo": {
  "systemType": ""
 },
 "libraryExportPath": "D:/REPOS/control-modules/control_library_standard/Drivers/ISAAC/ISAACPlayer24H",
 "license": "1GNTlyr7sewU1l3S6nhV4rvwzOeX/frwQLXVqzCH5QkDvcgrBIbzVD5M+lNXYkkDFor3HRqK7nVZuKWy9imZgUyvl2KouD5gJvg2czLEiro=",
 "name": "ISAACPlayer24H",
 "properties": [
  {
   "area": "Startup",
   "cont": "http://100.92.64.70",
   "name": "ISAAC URL",
   "typeHint": "string"
  },
  {
   "area": "Startup",
   "cont": "pixeraMediaTwo",
   "name": "ISAAC Module ID ",
   "typeHint": "string"
  },
  {
   "area": "Startup",
   "cont": "Timeline Main",
   "name": "Timeline Main Name",
   "typeHint": "string"
  },
  {
   "area": "Startup",
   "cont": "D:/My Media/",
   "name": "ISAAC Downloaded Media Directory",
   "typeHint": "string"
  },
  {
   "area": "Content",
   "cont": "My Media",
   "name": "Pixera Media Resource Folder",
   "typeHint": "string"
  },
  {
   "area": "Content",
   "cont": "Never",
   "name": "Delete Unscheduled Media",
   "optionsSourceFunc": "self.Helper.getDelUnscheduledMediaModes",
   "typeHint": "string"
  },
  {
   "area": "Content",
   "cont": "Never",
   "name": "Remove Assets Mode",
   "optionsSourceFunc": "self.Helper.assetCleanMode",
   "typeHint": "string"
  },
  {
   "area": "Content",
   "cont": "02:00",
   "name": "Delete Unscheduled Media Time (24h) (hh:mm)",
   "typeHint": "number"
  },
  {
   "area": "Timeline",
   "cont": "Layer Play",
   "name": "Content Layer Name",
   "typeHint": "string"
  },
  {
   "area": "Timeline",
   "cont": "Enabled",
   "name": "Instant Play Mode",
   "optionsSourceFunc": "self.Helper.instantplayModes",
   "typeHint": "string"
  },
  {
   "area": "Timeline",
   "cont": "Timeline Instant",
   "name": "Timeline Instant Name",
   "typeHint": "string"
  },
  {
   "area": "Timeline",
   "cont": "true",
   "name": "Wait For Instant Media",
   "typeHint": "bool"
  },
  {
   "area": "Timeline",
   "cont": "2000",
   "name": "Instant Play Fadetime (ms)",
   "typeHint": "number"
  },
  {
   "area": "Timeline",
   "cont": "Layer Audio",
   "name": "Audio Layer Name",
   "typeHint": "string"
  },
  {
   "area": "Timeline",
   "cont": "5",
   "name": "Keep Clips For Minutes After Ending",
   "typeHint": "number"
  },
  {
   "area": "Timeline",
   "cont": "5",
   "name": "Max Playables To Build On Timeline",
   "typeHint": "number"
  },
  {
   "area": "Timeline",
   "cont": "false",
   "name": "Fade If Overlapping",
   "typeHint": "bool"
  },
  {
   "area": "Transition",
   "cont": "Layer Blend",
   "name": "Transition Layer Name",
   "typeHint": "string"
  },
  {
   "area": "Transition",
   "cont": "My Transition",
   "name": "Transition Resource Folder",
   "typeHint": "string"
  },
  {
   "area": "Transition",
   "cont": "Media Overlay Random",
   "name": "Transition Mode",
   "optionsSourceFunc": "self.Helper.transitionMode",
   "typeHint": "string"
  },
  {
   "area": "Transition",
   "cont": "pexels-agustin-jo-15172866.jpg",
   "name": "Transition Media Overlay Fixed Resource",
   "typeHint": "string"
  },
  {
   "area": "Transition",
   "cont": "5000",
   "name": "Transition Duration (ms)",
   "typeHint": "number"
  },
  {
   "area": "Transition",
   "cont": "1000",
   "name": "Transition Dissolve In (ms)",
   "typeHint": "number"
  },
  {
   "area": "Transition",
   "cont": "2000",
   "name": "Transition Dissolve Out (ms)",
   "typeHint": "number"
  },
  {
   "area": "Transition",
   "cont": "0",
   "name": "Transition Offset (ms)",
   "typeHint": "string"
  },
  {
   "area": "Transition",
   "cont": "Stills",
   "name": "Apply Transition Dissolve To",
   "optionsSourceFunc": "self.Helper.getApplyTransitionDurationModes",
   "typeHint": "string"
  },
  {
   "area": "Transition",
   "cont": "10",
   "name": "Max Transtition Length (s)",
   "typeHint": "number"
  },
  {
   "area": "Transition",
   "cont": "Transition Duration",
   "name": "Transition Duration Of Video",
   "optionsSourceFunc": "self.Helper.limitVideoBlendDurationMode",
   "typeHint": "string"
  },
  {
   "area": "Composition",
   "cont": "true",
   "name": "Enable Compositions",
   "typeHint": "bool"
  },
  {
   "area": "Composition",
   "cont": "AudioTest;AVTest",
   "name": "Composition Groups",
   "typeHint": "string"
  },
  {
   "area": "Composition",
   "cont": "true",
   "name": "Merge To Transition Layer",
   "typeHint": "bool"
  },
  {
   "area": "Expert",
   "cont": "30s",
   "name": "Scheduler Update Interval",
   "typeHint": "string"
  },
  {
   "area": "Expert",
   "cont": "3s",
   "name": "Heartbeat Interval",
   "typeHint": "number"
  },
  {
   "area": "Expert",
   "cont": "false",
   "name": "Use Timecode",
   "typeHint": "bool"
  },
  {
   "area": "Expert",
   "cont": "100",
   "name": "Max Log Length (Web)",
   "typeHint": "number"
  },
  {
   "area": "Expert",
   "cont": "true",
   "name": "Hide Downloader Console",
   "typeHint": "bool"
  },
  {
   "area": "Expert",
   "cont": "false",
   "name": "Wait For SMB Transfers",
   "typeHint": "bool"
  },
  {
   "area": "Expert",
   "cont": "30",
   "name": "Timer Reset (Min)",
   "typeHint": "number"
  },
  {
   "area": "Expert",
   "cont": "Any",
   "name": "Network Adapter",
   "optionsSourceFunc": "Utils.Network.getLocalAdapterEntries",
   "typeHint": "string"
  },
  {
   "area": "Expert",
   "cont": "Local",
   "name": "LiveSystemToMonitor",
   "typeHint": "string"
  },
  {
   "area": "Expert",
   "cont": "",
   "name": "Schedule ID For Schedule (If Different)",
   "typeHint": "string"
  },
  {
   "area": "Expert",
   "cont": "1800",
   "name": "Max Maintenance (s)",
   "typeHint": "number"
  },
  {
   "area": "Expert",
   "cont": "true",
   "name": "Pause Timeline UI Update",
   "typeHint": "bool"
  },
  {
   "area": "Expert",
   "cont": "true",
   "name": "Reinit On SystemTimeChange",
   "typeHint": "bool"
  },
  {
   "area": "Expert",
   "cont": "false",
   "name": "UI Is Editable",
   "typeHint": "bool"
  },
  {
   "area": "Expert",
   "cont": "",
   "name": "Auth Source",
   "typeHint": "string"
  },
  {
   "area": "Expert",
   "cont": "",
   "name": "Permissions",
   "typeHint": "string"
  },
  {
   "area": "Expert",
   "cont": "{}",
   "name": "VariableData",
   "typeHint": "string"
  },
  {
   "cont": "1.0",
   "name": "Version",
   "readOnly": true,
   "typeHint": "string"
  },
  {
   "cont": "false",
   "name": "Auto Init",
   "typeHint": "bool"
  },
  {
   "cont": "{\"isInEditMode\":false,\"pages\":[{\"name\":\"Page1\",\"bgColor\":null,\"components\":[{\"componentId\":\"Component_1680773244824_78121\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLayout\",\"bgColor\":\"\",\"dims\":{\"x\":20,\"y\":760,\"width\":550,\"height\":140},\"invoc\":[],\"style\":\"\",\"styleCache\":\"\",\"styleClasses\":[\"\"],\"styleActions\":[],\"data\":{\"layout\":\"flow\",\"controls\":[],\"linkedAction\":[]}},{\"componentId\":\"Component_1680772939565_64068\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLayout\",\"bgColor\":\"\",\"dims\":{\"x\":20,\"y\":560,\"width\":550,\"height\":180},\"invoc\":[],\"style\":\"\",\"styleCache\":\"\",\"styleClasses\":[\"\"],\"styleActions\":[],\"data\":{\"layout\":\"flow\",\"controls\":[],\"linkedAction\":[]}},{\"componentId\":\"Component_1680772909262_58736\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLayout\",\"bgColor\":\"\",\"dims\":{\"x\":20,\"y\":320,\"width\":550,\"height\":220},\"invoc\":[],\"style\":\"\",\"styleCache\":\"\",\"styleClasses\":[\"\"],\"styleActions\":[],\"data\":{\"layout\":\"flow\",\"controls\":[],\"linkedAction\":[]}},{\"componentId\":\"Component_1679993680147_2217\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLayout\",\"bgColor\":\"\",\"dims\":{\"x\":20,\"y\":20,\"width\":550,\"height\":280},\"invoc\":[],\"style\":\"\",\"styleCache\":\"\",\"styleClasses\":[\"\"],\"styleActions\":[[]],\"data\":{\"layout\":\"flow\",\"controls\":[],\"linkedAction\":[]}},{\"componentId\":\"Component_1654075916296_80585\",\"label\":\"Current Playable:\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":370,\"width\":230,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1654075916296_80585 > .ComponentId_Component_1654075916296_80585 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1654075916296_80585 > .ComponentId_Component_1654075916296_80585.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1654075975183_65268\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlSlider\",\"bgColor\":\"transparent\",\"dims\":{\"x\":260,\"y\":410,\"width\":130,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.fader{\\n\\tbackground-color: #1a1e2280;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1654075975183_65268 > .ComponentId_Component_1654075975183_65268 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1654075975183_65268 > .ComponentId_Component_1654075975183_65268.fader {\\n    background-color: #1a1e2280; }\\n\",\"styleClasses\":[\"fader\"],\"styleActions\":[],\"data\":{\"minimum\":0,\"maximum\":100,\"default\":0,\"onlyIntegerValues\":false,\"showResetButton\":false,\"resetButtonLabel\":\"\",\"resetButtonFadeTime\":\"0ms\",\"showToggleButton\":false,\"toggleButtonLabel\":\"\",\"toggleButtonFadeTime\":\"0ms\",\"lockLinkedAction\":false,\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"currentMediaStatus\",\"params\":[{\"type\":\"undefined\",\"name\":\"val\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"jumpable\":false,\"orientation\":\"horizontal\"}},{\"componentId\":\"Component_1654084423418_59284\",\"label\":\"Memory:\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":810,\"width\":100,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1654084423418_59284 > .ComponentId_Component_1654084423418_59284 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1654084423418_59284 > .ComponentId_Component_1654084423418_59284.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1654084437255_92584\",\"label\":\"29.0 GB / 31.8 GB (90.9 %)\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":260,\"y\":810,\"width\":270,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1654084437255_92584 > .ComponentId_Component_1654084437255_92584 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1654084437255_92584 > .ComponentId_Component_1654084437255_92584.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"MemoryUsage\",\"params\":[{\"type\":\"undefined\",\"name\":\"val\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1654084458212_31458\",\"label\":\"CPU:\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":850,\"width\":100,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1654084458212_31458 > .ComponentId_Component_1654084458212_31458 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1654084458212_31458 > .ComponentId_Component_1654084458212_31458.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1654084473218_40100\",\"label\":\"0.4 %\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":260,\"y\":850,\"width\":290,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1654084473218_40100 > .ComponentId_Component_1654084473218_40100 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1654084473218_40100 > .ComponentId_Component_1654084473218_40100.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"CpuUsage\",\"params\":[{\"type\":\"undefined\",\"name\":\"val\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1654084954651_4817\",\"label\":\"Progress:\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":410,\"width\":230,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1654084954651_4817 > .ComponentId_Component_1654084954651_4817 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1654084954651_4817 > .ComponentId_Component_1654084954651_4817.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1654085350615_2749\",\"label\":\"Transition Playable:\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":450,\"width\":170,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1654085350615_2749 > .ComponentId_Component_1654085350615_2749 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1654085350615_2749 > .ComponentId_Component_1654085350615_2749.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1654085353700_49413\",\"label\":\"Progress:\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":490,\"width\":170,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1654085353700_49413 > .ComponentId_Component_1654085353700_49413 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1654085353700_49413 > .ComponentId_Component_1654085353700_49413.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1654085380192_60968\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlSlider\",\"bgColor\":\"transparent\",\"dims\":{\"x\":260,\"y\":490,\"width\":130,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.fader{\\n\\tbackground-color: #1a1e2280;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1654085380192_60968 > .ComponentId_Component_1654085380192_60968 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1654085380192_60968 > .ComponentId_Component_1654085380192_60968.fader {\\n    background-color: #1a1e2280; }\\n\",\"styleClasses\":[\"fader\"],\"styleActions\":[],\"data\":{\"minimum\":0,\"maximum\":100,\"default\":0,\"onlyIntegerValues\":false,\"showResetButton\":false,\"resetButtonLabel\":\"\",\"resetButtonFadeTime\":\"0ms\",\"showToggleButton\":false,\"toggleButtonLabel\":\"\",\"toggleButtonFadeTime\":\"0ms\",\"lockLinkedAction\":false,\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"TransitionStatus\",\"params\":[{\"type\":\"undefined\",\"name\":\"val\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"jumpable\":false,\"orientation\":\"horizontal\"}},{\"componentId\":\"Component_1654085412336_1869\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":260,\"y\":450,\"width\":290,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1654085412336_1869 > .ComponentId_Component_1654085412336_1869 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1654085412336_1869 > .ComponentId_Component_1654085412336_1869.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"TransitionMedia\",\"params\":[{\"type\":\"undefined\",\"name\":\"val\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_MXrILnBa0yGik2GH-YlSm\",\"label\":\"Status:\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":610,\"width\":100,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_MXrILnBa0yGik2GH_YlSm > .ComponentId_Component_MXrILnBa0yGik2GH_YlSm {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_MXrILnBa0yGik2GH_YlSm > .ComponentId_Component_MXrILnBa0yGik2GH_YlSm.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_NornulaAoF4_zwSCLUzZ_\",\"label\":\"Playable:\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":650,\"width\":120,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_NornulaAoF4_zwSCLUzZ_ > .ComponentId_Component_NornulaAoF4_zwSCLUzZ_ {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_NornulaAoF4_zwSCLUzZ_ > .ComponentId_Component_NornulaAoF4_zwSCLUzZ_.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_KNSA6NonqJCQFqsXJjS99\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":260,\"y\":650,\"width\":230,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_KNSA6NonqJCQFqsXJjS99 > .ComponentId_Component_KNSA6NonqJCQFqsXJjS99 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_KNSA6NonqJCQFqsXJjS99 > .ComponentId_Component_KNSA6NonqJCQFqsXJjS99.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"PlayInstantModeFile\",\"params\":[{\"type\":\"undefined\",\"name\":\"val\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_fIHctAEcDHIThMSvAKrqE\",\"label\":\"Stop\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":260,\"y\":610,\"width\":240,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_fIHctAEcDHIThMSvAKrqE > .ComponentId_Component_fIHctAEcDHIThMSvAKrqE {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_fIHctAEcDHIThMSvAKrqE > .ComponentId_Component_fIHctAEcDHIThMSvAKrqE.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"PlayInstantMode\",\"params\":[{\"type\":\"undefined\",\"name\":\"val\",\"value\":0},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1679491306299_95807\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlImage\",\"bgColor\":\"transparent\",\"dims\":{\"x\":290,\"y\":30,\"width\":200,\"height\":50},\"invoc\":[],\"style\":\"\",\"styleCache\":\"\",\"styleClasses\":[\"\"],\"styleActions\":[[]],\"data\":{\"src\":\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABOAAAAHkCAYAAACXElDBAAAAAXNSR0IArs4c6QAAQABJREFUeAHsvQmcXMd52Fmvew4MCcwMT5AiKQI2JNuUZIKm1pYs2QJkSj4Um6BtKtkcSzDrJJtde0l4ncSx44CIHd8xSW8iZ1deA8z6iimboGVJlGgZIClRJ0XwAECCOAbn4J6eA3P18fJ9r7umX7/pnu7p6e539L9+6KlXd9W/Xj28+t5XVcZgIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAA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Ysdr71zW0zPUcCzDLC9PtJ9yZvOW1R/6wJYzrvjo5onSkqGiqqquMF7VG1at6k4m4FLfcOpFgAABAgQIECBAgAABAgQIEHhfQALufQqFxSBw4NHUbdviYcWKeCgpiYfCwlgY7Sod6umsjHV01O3908unvbTpyWvfeXP3h1vbBk46GjHX1pS8t/q0Vc+t3XDRz1auPfvV+LLlraGioTvEx/qTibfxUDc0GkJT8ick93krGD8aMbkGAQIECBAgQIAAAQIECBAgsHQEJOCWznv1FxNpxv5wqb/RRGh5ozy5P1xtGOqpHNu7d+V4574VPe/uXv3en3ef1rKr5fSujv7lbT3DdX2j48VDY+OF+WAlYgXjFYnCobryRFdNTWnriublb606qflPlSes3FFQU783tnzVu+PFVd1F9fWtYaKsN5kkHAqbN4dw5ZWppNuEfd7yUXcOAQIECBAgQIAAAQIECBA4/gXix/8SrXCpCRxKZE2k404m5CZCvLYwFIX+oZHRWGF5WffEUFVxaf3yvWvKyvpPPmF5y3hPX13o76uZGB4tCoNDFfvb+2oH+oYqC0bH4+Mj48Wtg2PFYXwi9WUPIfl7or44PhSLJx8XjReOFpfFe1fUlneG0qLegsL4SEFlWWcoL++IVdfuKygt7SmoqO6IlVd2jZeW9RaVVPaFRM1gqK0dSsaZ+tSbFwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIJCjwP8DIL43oaTFFeAAAAAASUVORK5CYII=\",\"size\":\"\"}},{\"componentId\":\"Component_1679993736770_35817\",\"label\":\"Log\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":140,\"width\":100,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1679993736770_35817 > .ComponentId_Component_1679993736770_35817 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1679993736770_35817 > .ComponentId_Component_1679993736770_35817.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[[]],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1679993749698_65801\",\"label\":\"ISAAC Running\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":110,\"width\":160,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1679993749698_65801 > .ComponentId_Component_1679993749698_65801 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1679993749698_65801 > .ComponentId_Component_1679993749698_65801.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[[]],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1679993768123_36448\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLayout\",\"bgColor\":null,\"dims\":{\"x\":210,\"y\":117,\"width\":15,\"height\":15},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.online{\\n\\tbackground-color: #2aec71ff;\\n\\t\\n}\\n\\n&.offline{\\n\\tbackground-color: #ff0000ff;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1679993768123_36448 > .ComponentId_Component_1679993768123_36448 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1679993768123_36448 > .ComponentId_Component_1679993768123_36448.online {\\n    background-color: #2aec71ff; }\\n  #ComponentId_Component_1679993768123_36448 > .ComponentId_Component_1679993768123_36448.offline {\\n    background-color: #ff0000ff; }\\n\",\"styleClasses\":[\"online\"],\"styleActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"HeartbeatOK\",\"params\":[{\"type\":\"undefined\",\"name\":\"val\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"data\":{\"layout\":\"flow\",\"controls\":[],\"linkedAction\":[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"HeartbeatOK\",\"params\":[{\"type\":\"undefined\",\"name\":\"val\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]}},{\"componentId\":\"Component_1679993840222_33621\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlButton\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":70,\"width\":100,\"height\":30},\"invoc\":[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"start\",\"params\":[{\"type\":\"bool\",\"name\":\"val\",\"value\":false},{\"type\":\"bool\",\"name\":\"doSet\",\"value\":true}]}],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tbackground-color: #1a1f2380;\\n\\ttext-align: center;\\nborder-left: 1px solid #ffffff;\\nborder-top: 1px solid #ffffff;\\nborder-right: 1px solid #ffffff;\\nborder-bottom: 1px solid #ffffff;\\nborder-top-left-radius: 0px;\\nborder-top-right-radius: 0px;\\nborder-bottom-right-radius: 0px;\\nborder-bottom-left-radius: 0px;\\n\\n}\\n\\n/* Auto generated code END */\\n::after{\\n        content: \\\"Start\\\";\\n    }\\n    .active{\\n        background-color: #1a1f23;\\n        &::after{ \\n            content: \\\"Stop\\\";\\n        }\\n    }\",\"styleCache\":\"#ComponentId_Component_1679993840222_33621 > .ComponentId_Component_1679993840222_33621 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1679993840222_33621 > .ComponentId_Component_1679993840222_33621.Style1 {\\n    background-color: #1a1f2380;\\n    text-align: center;\\n    border-left: 1px solid #ffffff;\\n    border-top: 1px solid #ffffff;\\n    border-right: 1px solid #ffffff;\\n    border-bottom: 1px solid #ffffff;\\n    border-top-left-radius: 0px;\\n    border-top-right-radius: 0px;\\n    border-bottom-right-radius: 0px;\\n    border-bottom-left-radius: 0px; }\\n  #ComponentId_Component_1679993840222_33621 > .ComponentId_Component_1679993840222_33621 ::after {\\n    content: \\\"Start\\\"; }\\n  #ComponentId_Component_1679993840222_33621 > .ComponentId_Component_1679993840222_33621 .active {\\n    background-color: #1a1f23; }\\n    #ComponentId_Component_1679993840222_33621 > .ComponentId_Component_1679993840222_33621 .active::after {\\n      content: \\\"Stop\\\"; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[[]],\"data\":{\"toggle\":true,\"selectionGroup\":\"\",\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"started\",\"params\":[{\"type\":\"bool\",\"name\":\"val\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"toggleActions\":[],\"releaseActions\":[]}},{\"componentId\":\"Component_1679993949331_25500\",\"label\":\"Operation\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":30,\"width\":160,\"height\":40},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.header{\\n\\tfont-size: 20px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1679993949331_25500 > .ComponentId_Component_1679993949331_25500 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1679993949331_25500 > .ComponentId_Component_1679993949331_25500.header {\\n    font-size: 20px; }\\n\",\"styleClasses\":[\"header\"],\"styleActions\":[[]],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1679994023283_33721\",\"label\":\"Schedule\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":330,\"width\":160,\"height\":40},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.header{\\n\\tfont-size: 20px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1679994023283_33721 > .ComponentId_Component_1679994023283_33721 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1679994023283_33721 > .ComponentId_Component_1679994023283_33721.header {\\n    font-size: 20px; }\\n\",\"styleClasses\":[\"header\"],\"styleActions\":[[]],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1679996786155_73303\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":410,\"y\":410,\"width\":160,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1679996786155_73303 > .ComponentId_Component_1679996786155_73303 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1679996786155_73303 > .ComponentId_Component_1679996786155_73303.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"CurrentMediaTime\",\"params\":[{\"type\":\"string\",\"name\":\"val\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1679997064731_40610\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":410,\"y\":490,\"width\":140,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1679997064731_40610 > .ComponentId_Component_1679997064731_40610 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1679997064731_40610 > .ComponentId_Component_1679997064731_40610.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"TransitionMediaTime\",\"params\":[{\"type\":\"string\",\"name\":\"val\",\"value\":\"\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1679997113603_47965\",\"label\":\"Instant\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":570,\"width\":160,\"height\":40},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.header{\\n\\tfont-size: 20px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1679997113603_47965 > .ComponentId_Component_1679997113603_47965 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1679997113603_47965 > .ComponentId_Component_1679997113603_47965.header {\\n    font-size: 20px; }\\n\",\"styleClasses\":[\"header\"],\"styleActions\":[[]],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1679997169491_94359\",\"label\":\"Progress:\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":690,\"width\":100,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1679997169491_94359 > .ComponentId_Component_1679997169491_94359 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1679997169491_94359 > .ComponentId_Component_1679997169491_94359.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1679997173484_11044\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlSlider\",\"bgColor\":\"transparent\",\"dims\":{\"x\":260,\"y\":690,\"width\":130,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.fader{\\n\\tbackground-color: #1a1e2280;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1679997173484_11044 > .ComponentId_Component_1679997173484_11044 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1679997173484_11044 > .ComponentId_Component_1679997173484_11044.fader {\\n    background-color: #1a1e2280; }\\n\",\"styleClasses\":[\"fader\"],\"styleActions\":[],\"data\":{\"minimum\":0,\"maximum\":100,\"default\":0,\"onlyIntegerValues\":false,\"showResetButton\":false,\"resetButtonLabel\":\"\",\"resetButtonFadeTime\":\"0ms\",\"showToggleButton\":false,\"toggleButtonLabel\":\"\",\"toggleButtonFadeTime\":\"0ms\",\"lockLinkedAction\":false,\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"PlayInstantModeStatus\",\"params\":[{\"type\":\"Int32\",\"name\":\"val\",\"value\":0},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"jumpable\":false,\"orientation\":\"horizontal\"}},{\"componentId\":\"Component_1679997183916_5237\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":410,\"y\":690,\"width\":140,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1679997183916_5237 > .ComponentId_Component_1679997183916_5237 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1679997183916_5237 > .ComponentId_Component_1679997183916_5237.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"PlayInstantMediaTime\",\"params\":[{\"type\":\"string\",\"name\":\"val\",\"value\":\"\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1679997237861_12628\",\"label\":\"System\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":770,\"width\":160,\"height\":40},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.header{\\n\\tfont-size: 20px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1679997237861_12628 > .ComponentId_Component_1679997237861_12628 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1679997237861_12628 > .ComponentId_Component_1679997237861_12628.header {\\n    font-size: 20px; }\\n\",\"styleClasses\":[\"header\"],\"styleActions\":[[]],\"data\":{\"linkedActions\":[],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Component_1680170197557_17674\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlList\",\"bgColor\":\"\",\"dims\":{\"x\":70,\"y\":180,\"width\":440,\"height\":100},\"invoc\":[],\"style\":\"\",\"styleCache\":\"\",\"styleClasses\":[\"\"],\"styleActions\":[[]],\"data\":{\"indicatorPos\":\"left\",\"values\":[{\"color\":\"#2aec71\",\"value\":\"2023-10-08 10:25:18.516 | Initializing\"}],\"linkedAction\":[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"ErrorList\",\"params\":[{\"type\":\"string\",\"name\":\"val\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}],\"allwaysScrollDown\":false}},{\"componentId\":\"Component_1680785995697_60057\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":260,\"y\":370,\"width\":180,\"height\":30},\"invoc\":[],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\tfont-size: 18px;\\n\\t\\n}\\n\\n/* Auto generated code END */\\n\",\"styleCache\":\"#ComponentId_Component_1680785995697_60057 > .ComponentId_Component_1680785995697_60057 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Component_1680785995697_60057 > .ComponentId_Component_1680785995697_60057.Style1 {\\n    font-size: 18px; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"currentMedia\",\"params\":[{\"type\":\"undefined\",\"name\":\"val\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Label1\",\"label\":\"ISAACPlayer24H\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlLabel\",\"bgColor\":\"\",\"dims\":{\"x\":330,\"y\":80,\"width\":200,\"height\":30},\"invoc\":[],\"style\":\"\",\"styleCache\":\"\",\"styleClasses\":[\"\"],\"styleActions\":[],\"data\":{\"linkedActions\":[[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"ModuleName\",\"params\":[{\"type\":\"string\",\"name\":\"val\"},{\"type\":\"bool\",\"name\":\"doSet\"}]}]],\"scroll\":\"none\",\"scrollDuration\":\"10\",\"scrollDelay\":\"0\"}},{\"componentId\":\"Button1\",\"label\":\"\",\"preventFromClick\":false,\"visible\":true,\"fix\":false,\"type\":\"UbControlButton\",\"bgColor\":\"\",\"dims\":{\"x\":330,\"y\":130,\"width\":180,\"height\":30},\"invoc\":[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"Maintenance\",\"params\":[{\"type\":\"bool\",\"name\":\"val\",\"value\":false},{\"type\":\"bool\",\"name\":\"doSet\",\"value\":true}]}],\"style\":\"/* Auto generated code START */\\n&.Style1{\\n\\ttext-align: center;\\n\\tborder-left: 1px solid #ffffff;\\nborder-top: 1px solid #ffffff;\\nborder-right: 1px solid #ffffff;\\nborder-bottom: 1px solid #ffffff;\\nborder-top-left-radius: 0px;\\nborder-top-right-radius: 0px;\\nborder-bottom-right-radius: 0px;\\nborder-bottom-left-radius: 0px;\\n\\n}\\n\\n/* Auto generated code END */\\n::after{\\n        content: \\\"Maintenance Mode\\\";\\n    }\\n    .active{\\n        background-color: #1a1f;\\n        &::after{ \\n            content: \\\"Maintenance Mode\\\";\\n        }\\n    }\\n\\n\",\"styleCache\":\"#ComponentId_Button1 > .ComponentId_Button1 {\\n  /* Auto generated code START */\\n  /* Auto generated code END */ }\\n  #ComponentId_Button1 > .ComponentId_Button1.Style1 {\\n    text-align: center;\\n    border-left: 1px solid #ffffff;\\n    border-top: 1px solid #ffffff;\\n    border-right: 1px solid #ffffff;\\n    border-bottom: 1px solid #ffffff;\\n    border-top-left-radius: 0px;\\n    border-top-right-radius: 0px;\\n    border-bottom-right-radius: 0px;\\n    border-bottom-left-radius: 0px; }\\n  #ComponentId_Button1 > .ComponentId_Button1 ::after {\\n    content: \\\"Maintenance Mode\\\"; }\\n  #ComponentId_Button1 > .ComponentId_Button1 .active {\\n    background-color: #1a1f; }\\n    #ComponentId_Button1 > .ComponentId_Button1 .active::after {\\n      content: \\\"Maintenance Mode\\\"; }\\n\",\"styleClasses\":[\"Style1\"],\"styleActions\":[],\"data\":{\"toggle\":true,\"selectionGroup\":\"\",\"linkedActions\":[],\"toggleActions\":[],\"releaseActions\":[]}}],\"style\":\".fader{\\r\\n    .knob{\\r\\n        display:none;\\r\\n    }\\r\\n}\\r\\n--accent-color-dark: #2aec72;\",\"styleCache\":\"#page_Page1.type_UbPage.Page1 {\\n  --accent-color-dark: #2aec72; }\\n  #page_Page1.type_UbPage.Page1 .fader .knob {\\n    display: none; }\\n\",\"styleClasses\":[\"\"]},{\"name\":\"-FixPage\"}],\"devicePath\":\"ISAACPlayer24H\",\"version\":1,\"settings\":{\"onLoad\":[{\"kind\":\"interface\",\"name\":\"self\"},{\"kind\":\"ns\",\"name\":\"UI\"},{\"kind\":\"func\",\"name\":\"onLoad\"}],\"inspectorOrientation\":0},\"themeAndDesign\":{\"design\":\"Default\",\"theme\":\"Dark\",\"themes\":{}}}",
   "name": "uib",
   "typeHint": "string"
  }
 ],
 "separateCode": false,
 "uiUrl": "/static/ui_builder/ui_builder.html"
}